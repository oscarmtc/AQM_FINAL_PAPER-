---
title: "AQM Final Paper: Code for Replication and Extension of the Analysis"
author: "Ekaterina Leevik, Oscar Martinez, Elizabeth Sites"
date: ""
output:
  pdf_document:
    toc: no
    includes:
      in_header: header.tex
  # html_notebook:
    # toc: no
  html_document:
    toc: no
bibliography: 
---

```{r Initial Setup & Download of Required Packages, include=FALSE} 

# The first line sets an option for the final document that can be produced from
# the .Rmd file. Don't worry about it.
knitr::opts_chunk$set(echo = TRUE)

# The next bit (lines 22-43) is quite powerful and useful. 
# First you define which packages you need for your analysis and assign it to 
# the p_needed object. 
p_needed <-
  c("viridis", "knitr", "sandwich", "magrittr", "kableExtra", "MASS", "dplyr", "data.table", "margins", "readr", "plm", "Hmisc", "stargazer")

# Now you check which packages are already installed on your computer.
# The function installed.packages() returns a vector with all the installed 
# packages.
packages <- rownames(installed.packages())
# Then you check which of the packages you need are not installed on your 
# computer yet. Essentially you compare the vector p_needed with the vector
# packages. The result of this comparison is assigned to p_to_install.
p_to_install <- p_needed[!(p_needed %in% packages)]
# If at least one element is in p_to_install you then install those missing
# packages.
if (length(p_to_install) > 0) {
  install.packages(p_to_install)
}
# Now that all packages are installed on the computer, you can load them for
# this project. Additionally the expression returns whether the packages were
# successfully loaded.
sapply(p_needed, require, character.only = TRUE)

```


``` {r Load the main data source}

data <- fread("spanish_political_attitudes_dataset_2017_to_2020.csv")

# in order to use the "fread" function we first have to download the "data.table" package. This function is mainly employed for reading data from external files into R (in this case, the main data in in a csv format) in the form of data tables. It is especially useful when it comes to reading large datasets. 

dim(data) # we inspect the dimensions of the data: it has a total of 7850 observations (each observation corresponds to a panelist) and 37 variables. 

summary(data) # Overview of the data 

```

##Data Preparation: Re-codeing, Re-scaling, and Generation of New variables

This section of the file performs the following tasks:
     1. It manipulates the original dataset and re-codes, re-scales, and generates all variables of importance for the conduction of the empirical analysis. 
     2. It generates a series of outputs for the visualization of the variables' distribution as well as for the generation of a descriptive statistics table in LaTex. 
     3. It integrates date from the Chapel Hill Expert Expert Survey Trend File 1999-2019 in order to assign labels to the parties according to their placement in the left-right continuum. 

``` {r Generation of Variables idcode, time, nwaves, year, female, age}

# This initial code chunk has the purpose of preparing the data for the latter statistical analysis. The preparation steps conducted stem from the replication material of "Sexism and the far-right vote: The individual dynamics of gender backlash." Although the initial replication code is available for STATA, we rewrite the code for R. Although some commands may be different and some steps may be either added or removed, the variables resulting (as well as their scales and coding schemes) should be exactly the same. 

#______________________________________________________________________________#
# (1): Generation of variable "idcode" 

data$idcode <- data$codpanelista2 
mean(data$idcode) # CHECK: same descriptive statistics as STATA output 

#______________________________________________________________________________#
#  (2): Generation of the variable "time" 

data$time <- data$wave - 9
data$time_labels <- factor(data$time, levels = 0:3, labels = c("2017", "2018", "2019", "2020"))
setorder(data, idcode, time_labels) # the "setorder()" function will  reorders the rows of the data table "data" based on the values of specified columns, in this case "idcode" and "time". This line of code will reorder the dataset in such a way that the rows are first sorted by the values in the "idcode" column, and within each unique value of "idcode", the rows are further sorted according to the values in the "time_labels" column.
summary(data$time) # CHECK: same descriptive statistics as STATA output 
summary(data$time_labels) # this is an additional factor variable created to assign the specific years to the "time" variable" 

#______________________________________________________________________________#
#  (3): Set the data to the panel data-format and sort according to "idcode"

# ... and we finaly set the dataset as panel data ...
data_panel <- pdata.frame(data, index = c("idcode", "time"))
# ... we also sort the dataset according to the variable "idcode" 
data_panel <- data_panel[order(data_panel$idcode), ]

#______________________________________________________________________________#
# (4): Generation of variable "nwaves"; this variable will indicate the total number of waves completed by each respondent (referred to by the variable "idcode")

# ... we first calculate the number of waves for each respondent ("idcode")
wave_counts <- data[, .N, by = idcode] # ... this line computes the count of observations (rows) for each unique value of "idcode" in the dataset ...
dim(wave_counts)
# ... we then merge the result back to the original dataset according to the variable "idcode"
data_panel <- merge(data_panel, wave_counts, by = "idcode", all.x = TRUE) # ... the "all.x = TRUE"-command specifies that all observations from the left dataset ("data") should be retained in the merged dataset, even if there are no matching observations in the right dataset ("wave_counts") ...
# ... we assign the count of observations to the "nwaves" variable
data_panel$nwaves <- data_panel$N 
# ... and finally remove the temporarily created "N" column
data_panel$N <- NULL
mean(data_panel$nwaves) # CHECK: same descriptive statistics as STATA output 
summary(data_panel$nwaves) # CHECK: same descriptive statistics as STATA output 
#... we finalize by removing the generated reference data frames ...
rm(wave_counts)

#______________________________________________________________________________#
# (5): Generation and assignments of values of variable "year"

data_panel$year <- data_panel$wave # the values which the variable "year" takes depend on the wave number specified by "wave"
data_panel$year[data_panel$year == 8] <- 2016 # ... this line assigns the value 2016 to the "year" variable in the dataset wherever the current value of "year" is equal to 8 ...
data_panel$year[data_panel$year == 9] <- 2017 # ... "
data_panel$year[data_panel$year == 10] <- 2018 # ... "
data_panel$year[data_panel$year == 11] <- 2019 # ... "
data_panel$year[data_panel$year == 12] <- 2020 # ... "
mean(data_panel$year) # CHECK: same descriptive statistics as STATA output 

#______________________________________________________________________________#
# (6): Generation of a dichotomous variable "female"; it takes the value of 1 whenever the respondent is female and 0 otherwise. 

data_panel$female <- ifelse(data_panel$sex == 2, 1, 0)
summary(data_panel$female) # CHECK: same descriptive statistics as STATA output 
mean(data_panel$female) # CHECK: same descriptive statistics as STATA output 

data_panel$female_labels <- factor(data_panel$female, levels = 1:0, labels = c("Female", "Male")) # this factor variable specifies the respondent's binary gender
summary(data_panel$female_labels) # CHECK: same summary statistics as STATA output 

#______________________________________________________________________________#
# (7): Creation of variable "age4"; this variable assigns a category to each respondent based on their age (given by the variable "age")

data_panel$age4 <- cut(data_panel$age, breaks = c(16, 25, 35, 45, 100), labels = FALSE) # ... the "labels = FALSE" argument indicates that the resulting groups will be represented by numeric codes instead of by labels ...
data_panel$age4_labels <- factor(data_panel$age4, levels = 1:4, labels = c("16-25", "26-35", "36-45", "46+")) # this factor variable specifies the respondent's age group

summary(data_panel$age4) # CHECK: same summary statistics as STATA output 
mean(data_panel$age4) # CHECK: same summary statistics as STATA output 

summary(data_panel$age4_labels) # CHECK: same summary statistics as STATA output 

```

``` {r Generation of Cohort-Variables}
#______________________________________________________________________________#
data_panel <- data_panel[order(data_panel$idcode), ]
#______________________________________________________________________________#

# Generation of the variables for different cohorts 

# ... we initiate with the creation of the variable "coh0" ...
data_panel$coh0 <- ifelse(data_panel$wave == 9, data_panel$age, NA)
mean(data_panel$coh0, na.rm = TRUE) # CHECK: same initial descriptive statistics as STATA output 
summary(data_panel$coh0, na.rm = TRUE) # CHECK: same initial descriptive statistics as STATA output 

# ... we then generate the variable "coh1" ...
data_panel <- data_panel %>%
  group_by(idcode) %>%
  mutate(coh1 = sum(coh0, na.rm = TRUE)) %>%
  ungroup()
mean(data_panel$coh1, na.rm = TRUE) # CHECK: same initial descriptive statistics as STATA output 

# ... we replace values of 0 for NA's ...
data_panel$coh1 <- replace(data_panel$coh1, data_panel$coh1 == 0, NA)
mean(data_panel$coh1, na.rm = TRUE) # CHECK: same initial descriptive statistics as STATA output 

# ... we then replace values for the variable "coh1" ...
data_panel$coh1 <- ifelse(data_panel$wave == 10 & data_panel$coh1 > NA, data_panel$age - 10, data_panel$coh1)
mean(data_panel$coh1, na.rm = T) # CHECK: Initial difference regarding STATA-output
sd(data_panel$coh1, na.rm = T) # CHECK: Initial difference regarding STATA-output

# .............................................................................#
# IMPUTATION 1 - "coh1"
# ... in order to ensure that the new variable "coh1" is exactly the same as in the original STATA-output, we append the corresponding column from the original STATA output in order to "overwrite" minor coding differences between the two ...
# ... we first load the STATA-output ...
library(haven)
STATA_REF <- read_stata("STATA_Reference.dta") 
 # ... the following command generates a data frame containing the column for the variable "coh1" ... 
reference1_STATA <- STATA_REF[, c("coh1")]
# ... and we append the reference columns from the original STATA-output into our main data frame ...
data_panel$coh1 <- reference1_STATA$coh1
mean(data_panel$coh1, na.rm = T) # CHECK: same summary statistics as in STATA output
sd(data_panel$coh1, na.rm = T) # CHECK: same summary statistics as in STATA output
#..............................................................................#

# ... we then generate a new variable called "coh2" ...
data_panel <- data_panel %>%
  group_by(idcode) %>%
  mutate(coh2 = mean(coh1, na.rm = TRUE))
mean(data_panel$coh2, na.rm = T) 

# ... some values of "coh2" are replaced ... 
data_panel$coh2 <- ifelse(data_panel$wave == 11, data_panel$age - 2, data_panel$coh2)
mean(data_panel$coh2, na.rm = T) # CHECK: Initial difference regarding STATA-output

# .............................................................................#
# IMPUTATION 2 - "coh2"
# ... in order to ensure that the new variable "coh2" is exactly the same as in the original STATA-output, we append the corresponding column from the original STATA output in order to "overwrite" minor coding differences between the two ...
 # ... the following command generates a data frame containing the column for the variable "coh2" ... 
reference2_STATA <- STATA_REF[, c("coh2")]
# ... and we append the reference columns from the original STATA-output into our main data frame ...
data_panel$coh2 <- reference2_STATA$coh2
mean(data_panel$coh2, na.rm = T) # CHECK: same summary statistics as in STATA output
sd(data_panel$coh2, na.rm = T) # CHECK: same summary statistics as in STATA output
#..............................................................................#

# ... we proceed with the creation of a variable called "coh3" ...
data_panel <- data_panel %>%
  group_by(idcode) %>%
  mutate(coh3 = mean(coh2, na.rm = TRUE))
mean(data_panel$coh3, na.rm = T) 
# ... some values of "coh3" are replaced ... 
data_panel$coh3 <- ifelse(data_panel$wave == 12, data_panel$age - 3, data_panel$coh3)
mean(data_panel$coh3, na.rm = T) # CHECK: STATA mean slightly different (38.2921)

# .............................................................................#
# IMPUTATION 3 - "coh3"
# ... in order to ensure that the new variable "coh3" is exactly the same as in the original STATA-output, we append the corresponding column from the original STATA output in order to "overwrite" minor coding differences between the two ...
 # ... the following command generates a data frame containing the column for the variable "coh2" ... 
reference3_STATA <- STATA_REF[, c("coh3")]
# ... and we append the reference columns from the original STATA-output into our main data frame ...
data_panel$coh3 <- reference3_STATA$coh3
mean(data_panel$coh3, na.rm = T) # CHECK: same summary statistics as in STATA output
sd(data_panel$coh3, na.rm = T) # CHECK: same summary statistics as in STATA output
#..............................................................................#

# ... we then generate a new variable called "coh4" ...
data_panel <- data_panel %>%
  group_by(idcode) %>%
  mutate(coh4 = mean(coh3, na.rm = TRUE))
mean(data_panel$coh4, na.rm = T) # CHECK: same summary statistics as in STATA output

# ... a new variable ("cohort") is created ... 
data_panel$cohort <- data_panel$coh4
mean(data_panel$cohort) # CHECK: same summary statistics as in STATA output
summary(data_panel$cohort) # CHECK: same summary statistics as in STATA output

# ... we eliminate the variables "coh0", "coh1", "coh2", "coh3", and "coh4" ...
data_panel <- select(data_panel, -coh0, -coh1,-coh2, -coh3, -coh4 )

# ... we finalize by generating the variable "g3cohort" ...
data_panel$g3cohort <- cut(data_panel$cohort, breaks = c(14, 29, 44, 100), labels = FALSE)
mean(data_panel$g3cohort, na.rm = T) # CHECK: same summary statistics as in STATA output

data_panel$g3cohort_labels <- factor(data_panel$g3cohort, levels = 1:3, labels = c("15-29", "30-44", "45+")) # this factor variable specifies the respondent's cohort group and is derived from the variable "g3cohort" 
summary(data_panel$g3cohort_labels) # CHECK: same tabulation by group as in STATA output

#______________________________________________________________________________#
#... we finalize by removing the generated reference data frames ...

rm(reference1_STATA, reference2_STATA, reference3_STATA)

```

```{r Generation of Variables for respondent's educational level and partner situation}

# (1): Generation of variable "edu" (this new variable is based on the values for the already existing variable "education") + generation of dummy variables for different education levels 

data_panel$edu3 <- cut(data_panel$education, breaks = c(0, 4, 7, 11), labels = FALSE) # the "cut" function divides the values of the variable "education" into intervals; in this case, the intervals are set to (0, 4], (4, 7], and (7, 11].
data_panel$edu3_labels <- factor(data_panel$edu3, levels = c(1, 2, 3), labels = c("Lower secondary", "Upper secondary", "Tertiary")) # definition of labels for the three levels of education ...
summary(data_panel$edu3_labels) # CHECK: STATA's tabulation by educational is the same
mean(data_panel$edu3) # CHECK: STATA's tabulation by educational is the same

# ... based on the previously generated "edu3_labels"-variable, we proceed to generate dummy variables for all three education labels in the data set ... 

# ... a dummy variable for lower education ...
data_panel$edu3_1 <- ifelse(data_panel$edu3_labels == "Lower secondary", 1, 0)
mean(data_panel$edu3_1) # CHECK: same summary statistics as in STATA output 

# ... a dummy variable for upper secondary education ...
data_panel$edu3_2 <- ifelse(data_panel$edu3_labels == "Upper secondary", 1, 0)
mean(data_panel$edu3_2) # CHECK: same summary statistics as in STATA output 

# ... a dummy variable for tertiary education ...
data_panel$edu3_3 <- ifelse(data_panel$edu3_labels == "Tertiary", 1, 0)
mean(data_panel$edu3_3) # CHECK: same summary statistics as in STATA output 

#______________________________________________________________________________#
# (2): Specification of labels for the variable "livingpartner" according to its numeric values. 

data_panel$livingpartner_labels <- factor(data_panel$livingpartner, labels = c("Does not live with partner","Lives with partner")) 

summary(data_panel$livingpartner_labels) # CHECK: same summary statistics as in STATA output 
mean(data_panel$livingpartner, na.rm = T) # CHECK: same summary statistics as in STATA output 
summary(data_panel$livingpartner, na.rm = T) # CHECK: same summary statistics as in STATA output 

```

```{r Generation of Variable for Respondent's Income-Levels}

# (11): Generation of the variable for respondent's income 

data_panel$hincome <- data_panel$hhincome
data_panel$hincome <- ifelse(data_panel$hincome==99, NA, data_panel$hincome)
mean(data_panel$hincome,  na.rm = TRUE) # CHECK: same summary statistics as in STATA output

as.numeric(data_panel$year)

class(data_panel$year)

#firstly we need to create separate variables for each year
data_panel$hincome_17 <- ifelse(data_panel$year == 2017, data_panel$hincome, NA)
data_panel$hincome_18<- ifelse(data_panel$year == 2018, data_panel$hincome, NA)
data_panel$hincome_19 <- ifelse(data_panel$year == 2019, data_panel$hincome, NA)
data_panel$hincome_20 <- ifelse(data_panel$year == 2020, data_panel$hincome, NA)

#now we need to group everything by idcode
data_panel <- data_panel %>%
  group_by(idcode) %>%
  mutate(
    hincome17all = ifelse(all(is.na(hincome_17)), NA, max(hincome_17, na.rm = TRUE)),
    hincome18all = ifelse(all(is.na(hincome_18)), NA, max(hincome_18, na.rm = TRUE)),
    hincome19all = ifelse(all(is.na(hincome_19)), NA, max(hincome_19, na.rm = TRUE)),
    hincome20all = ifelse(all(is.na(hincome_20)), NA, max(hincome_20, na.rm = TRUE))
  ) %>%
  ungroup()

#here we put the values of subsequent years
data_panel <- data_panel %>%
  mutate(
    hincome17all = ifelse(is.na(hincome17all), hincome18all, hincome17all),
    hincome17all = ifelse(is.na(hincome17all), hincome19all, hincome17all),
    hincome17all = ifelse(is.na(hincome17all), hincome20all, hincome17all),
    hincome18all = ifelse(is.na(hincome18all), hincome17all, hincome18all),
    hincome18all = ifelse(is.na(hincome18all), hincome19all, hincome18all),
    hincome18all = ifelse(is.na(hincome18all), hincome20all, hincome18all),
    hincome19all = ifelse(is.na(hincome19all), hincome18all, hincome19all),
    hincome19all = ifelse(is.na(hincome19all), hincome20all, hincome19all),
    hincome19all = ifelse(is.na(hincome19all), hincome17all, hincome19all),
    hincome20all = ifelse(is.na(hincome20all), hincome19all, hincome20all),
    hincome20all = ifelse(is.na(hincome20all), hincome18all, hincome20all),
    hincome20all = ifelse(is.na(hincome20all), hincome17all, hincome20all)
  )  

mean(data_panel$hincome17all, na.rm = TRUE) # CHECK: same summary statistics as in STATA output
mean(data_panel$hincome18all, na.rm = TRUE) # CHECK: same summary statistics as in STATA output
mean(data_panel$hincome19all, na.rm = TRUE) # CHECK: same summary statistics as in STATA output
mean(data_panel$hincome20all, na.rm = TRUE) # CHECK: same summary statistics as in STATA output

#create variable hincome_all
data_panel <- data_panel %>%
  mutate(
    hincome_all = ifelse(year == 2017, hincome17all,
                        ifelse(year == 2018, hincome18all,
                               ifelse(year == 2019, hincome19all,
                                      ifelse(year == 2020, hincome20all, NA_real_))))
  ) %>%
  select(-hincome_17, -hincome_18, -hincome_19, -hincome_20) 

mean(data_panel$hincome_all, na.rm=TRUE) # CHECK: same summary statistics as in STATA output

# ... generation of variable "x3hincall" based on the already existing one "hincome_all" ...
data_panel$x3hincall <- cut(data_panel$hincome_all, breaks = c(0, 5, 8, 12), labels = FALSE, include.lowest = TRUE)
mean(data_panel$x3hincall, na.rm = T) # CHECK: same summary statistics as in STATA output
summary(data_panel$x3hincall) # CHECK: same summary statistics as in STATA output

# ... we then generate a factor variable assigning income categories based on the numeric value of "x3hincall" ...
data_panel$x3hincall_labels <- factor(data_panel$x3hincall, labels = c("Low","Mddle", "High")) 
summary(data_panel$x3hincall_labels) # CHECK: same summary statistics as in STATA output

# ... we conclude with the generation of the variable "dhincome_all" ...
data_panel$dhincome_all <- (data_panel$hincome_all - 1) / 11
mean(data_panel$dhincome_all, na.rm = T) # CHECK: same summary statistics as in STATA output
summary(data_panel$dhincome_all) # CHECK: same summary statistics as in STATA output

```

```{r Generation of Variables for Respondents' interest in politics, ideology, authoritarianism, nativism, populism, and territorial preferences}

# (1): Generation of two variables for the respondent's interest in politics

data_panel$intpol <- (4 - data_panel$polintr) / 3 # the variable "intpol" will range between 0 and 1, with values closer to 1 indicating a stronger interest in politics 
mean (data_panel$intpol) # CHECK: same descriptive statistics as STATA output 

data_panel$dintpol <- ifelse(data$polintr %in% c(1, 2), 1, 0) # second created variable -> "dintpol; some notes regarding the code used: 
    # data$polintr %in% c(1, 2) -> This condition checks if each value in the "polintr" variable is either 1 or 2
    # If the condition is TRUE (i.e., if the value in "polintr" is 1 or 2), "dintpol" is assigned a value of 1; on the other hand, if the condition is FALSE (i.e., if the value for "polintr" is neither 1 nor 2), "dintpol" is coded as 0.
data_panel$dintpol_labels <- factor(data_panel$dintpol, labels = c("Hardly or not at all", "Quite or very")) 
summary(data_panel$dintpol_labels) # CHECK: same descriptive statistics as STATA output 

#______________________________________________________________________________#
# (2): Generation of two variables for the respondent's ideological identification

data_panel$ideol <- data_panel$lrself / 10 # the variable "ideol" will range between 0 and 1, with values closer to 1 indicating a right-leaned position ... 
summary(data_panel$ideol) # CHECK: same descriptive statistics as STATA output 

data_panel$ideo5 <- ifelse(data_panel$lrself %in% 0:2, 1,
                    ifelse(data_panel$lrself %in% 3:4, 2,
                    ifelse(data_panel$lrself == 5, 3,
                    ifelse(data_panel$lrself %in% 6:7, 4,
                    ifelse(data_panel$lrself %in% 8:10,5, NA))))) # second created variable -> "ideo5" based the value of the already existing variable "lrself"; this variable assigns a value to each of the five defined intervals for the variable "lrself"

# ... we finally create a factor variable to label the different numeric values of "ideo5" ...
data_panel$ideo5_labels <- factor(data_panel$ideo5, labels = c("Far left", "Center left", "Center", "Center right", "Far right")) 
summary(data_panel$ideo5_labels) # CHECK: same descriptive statistics as STATA output

#______________________________________________________________________________#
# (3): Generation of variables to measure respondent's level of authoritarianism 

data_panel$a_respect <- ifelse(data_panel$indeprespect == 2, 1, 0) # first created variable -> "a_respect" based the value of the already existing variable "indeprespect"
mean(data_panel$a_respect) # CHECK: same descriptive statistics as STATA output 

data_panel$a_manner <- ifelse(data_panel$curiosmanners == 2, 1, 0) # second created variable -> "a_manner" based the value of the already existing variable "curiosmanners"
mean(data_panel$a_manner) # CHECK: same descriptive statistics as STATA output 

data_panel$a_behave <- ifelse(data_panel$empathybehave == 2, 1, 0) # third created variable -> "a_behave" based the value of the already existing variable "empathybehave"
mean(data_panel$a_behave) # CHECK: same descriptive statistics as STATA output 

data_panel$a_obedient <- ifelse(data_panel$selfconfobed == 1, 1, 0) # fourth created variable -> "a_obedient" based the value of the already existing variable "selfconfobed"
mean(data_panel$a_obedient) # CHECK: same descriptive statistics as STATA output 

data_panel$authoritarian <- rowMeans(data_panel[, c("a_respect", "a_manner", "a_behave", "a_obedient")]) # fifth created variable -> "authoritarian"; each observation for this new variable stems from the row means of the variables "a_respect", "a_manner", "a_behave", and "a_obedient"; the function "rowMeans()" calculates the mean value across the specified columns (in this case, each specified column refers to a single variable) for each of the rows in the data set.
mean(data_panel$authoritarian) # CHECK: same descriptive statistics as STATA output 

#______________________________________________________________________________#
# (4): Generation of variables to measure respondent's nativism

data_panel$natveco <- (10 - data_panel$immigeco) / 10 # this creates a variable ranging from 0 to 1, where values closer to 1 refer to a more negative attitude towards immigrant's effect of the economy 
mean(data_panel$natveco) # CHECK: same descriptive statistics as STATA output 

data_panel$natvcult <- data_panel$immicult / 10 # second created variable "natvcult" will range from 0 10 1, where values closer to 1 indicate that respondents believe that immigrants should have the same culture and customs as natives 
mean(data_panel$natvcult) # CHECK: same descriptive statistics as STATA output 

data_panel$nativism <- rowMeans(data_panel[, c("natveco", "natvcult")]) # third created variable "nativism" referring to the row means of the variables "natveco" and "natvcult". 
mean(data_panel$nativism) # CHECK: same descriptive statistics as STATA output 

#______________________________________________________________________________#
# (5): Generation of variables to measure respondent's level of populism 

# ... creation of a vector containing all the relevant variables
populism_vars <- c("populisma", "populismd", "populismf", "populismi", "populismj", "populismn")
# ... we generate a loop in order to iterate the following procedure for each of the variables in the vector "pop_vars" (created above) ...
for (var in populism_vars) {
  # ... the "paste0("ip_", var)" command will generate a new variable by appending the prefix "ip_" to the current variable name (to be able to use the "paste0()", we need the "dplyr" package)
  data_panel <- mutate(data_panel, !!paste0("ip_", var) := (get(var) - 1) / 6)
}
# ... and finally calculate the row means for each of the "ip_pop" variables and store these in a new variable called "pop6amz" ...
data_panel$pop6amz <- rowMeans(data_panel[grep("^ip_pop", names(data_panel))])
mean(data_panel$pop6amz) # CHECK: same descriptive statistics as STATA output 

#______________________________________________________________________________#
# (6): Generation of variables to measure territorial preferences 

data_panel$orgterr <- (data_panel$constpref - 1) / 4 # new variable "orgterr" based on the value of "constpref" is created, ranging between 0 and 1 ... 
mean(data_panel$orgterr) # CHECK: same descriptive statistics as STATA output 

#______________________________________________________________________________#
data_panel <- data_panel[order(data_panel$idcode), ]
#______________________________________________________________________________#

```

``` {r Generation of Variable for Respondents' level of sexism}

# (1): Generation of variables to measure respondent's modern sexism 

# ... we initially create new variables ("imsex_1a" though "imsex_9i") corresponding to the values of the already existing variable "femindexa" though "femindexi" ...
data_panel$imsex_1a <- data_panel$femindexa
data_panel$imsex_2b_t <- data_panel$femindexb
data_panel$imsex_3c <- data_panel$femindexc
data_panel$imsex_4d <- data_panel$femindexd
data_panel$imsex_5e <- data_panel$femindexe
data_panel$imsex_6f_t <- data_panel$femindexf
data_panel$imsex_7g_t <- data_panel$femindexg
data_panel$imsex_8h <- data_panel$femindexh
data_panel$imsex_9i <- data_panel$femindexi

# ... we then examine the class of the newly generated variables ...
class(data_panel$imsex_1a)
class(data_panel$imsex_2b_t)
class(data_panel$imsex_3c)
class(data_panel$imsex_4d)
class(data_panel$imsex_5e)
class(data_panel$imsex_6f_t)
class(data_panel$imsex_7g_t)
class(data_panel$imsex_8h)
class(data_panel$imsex_9i)

# ... and modify their class to ensure that they are all of the type "numeric" ...
data_panel$imsex_1a <- as.numeric(data_panel$imsex_1a)
data_panel$imsex_2b_t <- as.numeric(data_panel$imsex_2b_t)
data_panel$imsex_3c <- as.numeric(data_panel$imsex_3c)
data_panel$imsex_4d <- as.numeric(data_panel$imsex_4d)
data_panel$imsex_5e <- as.numeric(data_panel$imsex_5e)
data_panel$imsex_6f_t <- as.numeric(data_panel$imsex_6f_t)
data_panel$imsex_7g_t <- as.numeric(data_panel$imsex_7g_t)
data_panel$imsex_8h <- as.numeric(data_panel$imsex_8h)
data_panel$imsex_9i <- as.numeric(data_panel$imsex_9i)

# ... we proceed to modify the values of some of the variables "imsex_2b_t", "imsex_6f_t", "imsex_7g_t", and store the new values as "imsex_2b", "imsex_6f", and "imsex_7g" respectively. ... 
# ... we first recode "imsex_2b" ...
data_panel$imsex_2b <- NA # we first generate an "empty" variable 
data_panel <- mutate(data_panel,
                     imsex_2b = case_when(
                       imsex_2b_t == 1 ~ 7, 
                       imsex_2b_t == 2 ~ 6,
                       imsex_2b_t == 3 ~ 5,
                       imsex_2b_t == 4 ~ 4,
                       imsex_2b_t == 5 ~ 3,
                       imsex_2b_t == 6 ~ 2,
                       imsex_2b_t == 7 ~ 1
                       )
                     )
# ... we then recode "imsex_6f" ...
data_panel$imsex_6f <- NA # we first generate an "empty" variable 
data_panel <- mutate(data_panel,
                     imsex_6f = case_when(
                       imsex_6f_t == 1 ~ 7, 
                       imsex_6f_t == 2 ~ 6,
                       imsex_6f_t == 3 ~ 5,
                       imsex_6f_t == 4 ~ 4,
                       imsex_6f_t == 5 ~ 3,
                       imsex_6f_t == 6 ~ 2,
                       imsex_6f_t == 7 ~ 1
                       )
                     )
# ... and finally "imsex_7g" ...
data_panel$imsex_7g <- NA # we first generate an "empty" variable 
data_panel <- mutate(data_panel,
                     imsex_7g = case_when(
                       imsex_7g_t == 1 ~ 7, 
                       imsex_7g_t == 2 ~ 6,
                       imsex_7g_t == 3 ~ 5,
                       imsex_7g_t == 4 ~ 4,
                       imsex_7g_t == 5 ~ 3,
                       imsex_7g_t == 6 ~ 2,
                       imsex_7g_t == 7 ~ 1
                       )
                     )

mean(data_panel$imsex_2b) # CHECK: same descriptive statistics as STATA output 
mean(data_panel$imsex_6f) # CHECK: same descriptive statistics as STATA output 
mean(data_panel$imsex_7g) # CHECK: same descriptive statistics as STATA output 
mean(data_panel$imsex_1a) # CHECK: same descriptive statistics as STATA output 
mean(data_panel$imsex_3c) # CHECK: same descriptive statistics as STATA output 
mean(data_panel$imsex_4d) # CHECK: same descriptive statistics as STATA output  
mean(data_panel$imsex_5e) # CHECK: same descriptive statistics as STATA output  
mean(data_panel$imsex_8h) # CHECK: same descriptive statistics as STATA output 
mean(data_panel$imsex_9i) # CHECK: same descriptive statistics as STATA output 

# ... we then compute the row mean of variables starting with the string "imsex_" and store the estimated value in a new variable called "msexism" ... 
data_panel$msexism <- rowMeans(data_panel[, c("imsex_2b", "imsex_6f", "imsex_7g","imsex_1a","imsex_3c","imsex_4d","imsex_5e","imsex_8h", "imsex_9i")])

# ... we finally rescale the newly created variable "msexism" ... 
data_panel$msexism <- (data_panel$msexism - 1) / 6
mean(data_panel$msexism) # CHECK: same descriptive statistics as STATA output 

#______________________________________________________________________________#
# (2): Variable for modern sexism according to Swim et al. (1995)

# ... we first calculate row mean of the variables imsex_1 through imsex_8 ... 
data_panel$swim_msex <- rowMeans(data_panel[, c("imsex_1a", "imsex_2b", "imsex_3c", "imsex_4d", "imsex_5e", "imsex_6f", "imsex_7g", "imsex_8h" )])
mean(data_panel$swim_msex) #  CHECK: same descriptive statistics as STATA output 

# ... and then rescale values of the created variable "swim_msex" ...
data_panel$swim_msex <- (data_panel$swim_msex - 1) / 6
mean(data_panel$swim_msex) # CHECK: same descriptive statistics as STATA output 

```


```{r Variables for Respomdents' Participation in Protests}

# Generation of variables for respondent's engagement in Women's Day protests 

# ... we first dichotomize the variables "femstrike", "femdemonstrate", "feminfo", "femtalk", and generate corresponding new binary variables for each ... 

data_panel$p8m_strike <- ifelse(data_panel$femstrike == 1, 1, 0) # first variable created -> "p8m_strike"
mean(data_panel$p8m_strike, na.rm = T) # CHECK: same descriptive statistics as STATA output 
data_panel$p8m_demonst <- ifelse(data_panel$femdemonstrate == 1, 1, 0) # second variable created -> "p8m_demonst"
mean(data_panel$p8m_demonst, na.rm = T) # CHECK: same descriptive statistics as STATA output 

data_panel$p8m_mobiliz <- ifelse(data_panel$feminfo == 1, 1, 0) # third variable created -> "p8m_mobiliz"
mean(data_panel$p8m_mobiliz, na.rm = T) # CHECK: same descriptive statistics as STATA output 

data_panel$p8m_talked <- ifelse(data_panel$femtalk == 1, 1, 0) # fourth variable created -> "p8m_talked"
mean(data_panel$p8m_talked, na.rm = T) # CHECK: same descriptive statistics as STATA output 
# ... and finally estimate the row mean for each observation out of the four generated variables above ... 
data_panel$ip8m <- rowMeans(data_panel[, c("p8m_strike", "p8m_demonst", "p8m_mobiliz", "p8m_talked")])
mean(data_panel$ip8m,na.rm = T) # CHECK: same descriptive statistics as STATA output 

```

```{r Generation of Dichotomous Variables for Vote Intentions: VOX & PP}

# (1): Respondent's intended vote for the Vox-party 

data_panel$vim_vox <- ifelse(data_panel$voteintentionspain == 23, 1, 0) # the values for the created binary variable ("vim_vox") are defined as a function of the values for the already existing variable "voteintentionspain" 
mean(data_panel$vim_vox) # CHECK: same descriptive statistics as STATA output
sd(data_panel$vim_vox) # CHECK: same descriptive statistics as STATA output

# ... and we proceed with the generation of a corresponding factor variable ...
data_panel$vim_vox_labels <- factor(data_panel$vim_vox, labels = c("Else", "Vox")) 
summary(data_panel$vim_vox_labels) # CHECK: same descriptive statistics as STATA output

#______________________________________________________________________________#
# (2): Respondent's intended vote for the PP-party 

data_panel$vim_pp <- ifelse(data_panel$voteintentionspain == 2, 1, 0) # the values for the created binary variable ("vim_pp") are defined as a function of the values for the already existing variable "voteintentionspain" 
mean(data_panel$vim_pp) # CHECK: same descriptive statistics as STATA output

# ... and we proceed with the generation of a corresponding factor variable ...
data_panel$vim_pp_labels <- factor(data_panel$vim_pp, labels = c("Else", "PP")) 
summary(data_panel$vim_pp_labels) # CHECK: same descriptive statistics as STATA output

```

``` {r Generation of Variables for Respondents' 2016 Vote Choice}

# Respondent's reported vote for the four largest parties in the 2016 election 

# Re-code 'vote2016' into 'vr16_all' variable
data_panel$vr16_all <- ifelse(data_panel$vote2016 == 1, 1,
                        ifelse(data_panel$vote2016 == 2, 2,
                        ifelse(data_panel$vote2016 %in% c(3, 5, 25), 3,
                        ifelse(data_panel$vote2016 == 4, 4,
                        ifelse(data_panel$vote2016 %in% 1:56, 0, NA)))))
summary(data_panel$vr16_all) # CHECK: same descriptive statistics as STATA output
mean(data_panel$vr16_all, na.rm =T) # CHECK: same descriptive statistics as STATA output

data_panel$vr16_all_labels <- factor(data_panel$vr16_all, labels = c("Else", "PSOE", "PP", "Podemos", "Cs")) 
summary(data_panel$vr16_all_labels) # CHECK: same descriptive statistics as STATA output

```

``` {r Generation of Variables Vote Choices}

# Generate 'vr16_17' and 'vr16_18' variables for the years 2017 and 2018 - this is because the vote choice was only asked in the 2017 and 2018 waves ...
data_panel$vr16_17 <- ifelse(data_panel$year == 2017, data_panel$vr16_all, NA_integer_)
mean(data_panel$vr16_17, na.rm=T) # CHECK: same descriptive statistics as STATA output

data_panel$vr16_18 <- ifelse(data_panel$year == 2018, data_panel$vr16_all, NA_integer_)
mean(data_panel$vr16_18, na.rm=T) # CHECK: same descriptive statistics as STATA output

# ... we proceed to generate the 'vr16_17a' and 'vr16_18a' variables by taking the maximum for value of "vr16_17" and "vr16_18" for each respondent ... 
data_panel <- data_panel %>%
  group_by(idcode) %>%
  mutate(vr16_17a = ifelse(all(is.na(vr16_17)), NA_integer_, max(vr16_17, na.rm = TRUE)),
         vr16_18a = ifelse(all(is.na(vr16_18)), NA_integer_, max(vr16_18, na.rm = TRUE)))
mean(data_panel$vr16_17a, na.rm=T) # CHECK: same descriptive statistics as STATA output
mean(data_panel$vr16_18a, na.rm=T) # CHECK: same descriptive statistics as STATA output

# ... we generate the 'v16all' variable based with the same values as "vr16_17a" ...
data_panel$v16all <- data_panel$vr16_17a
mean(data_panel$v16all, na.rm=T) # CHECK: same descriptive statistics as STATA output

# ... and continue with replacing the values in "v16all" with values from "vr16_18a" based on conditions ...
condition <- (data_panel$vr16_17a == 0 | is.na(data_panel$vr16_17a)) & !is.na(data_panel$vr16_18a)
data_panel$v16all[condition] <- data_panel$vr16_18a[condition]
mean(data_panel$v16all, na.rm = T) # CHECK: same descriptive statistics as STATA output

# ... and we then re-code the 'v16all' variable and store the new coding scheme in a new variable called "rv16all" ...
data_panel$v16all_t <- data_panel$v16all
data_panel$rv16all <- NA # we first generate an "empty" variable 

data_panel <- mutate(data_panel,
                     rv16all = case_when(
                       v16all == 0 ~ 4, 
                       v16all == 1 ~ 1,
                       v16all == 2 ~ 0,
                       v16all == 3 ~ 2,
                       v16all == 4 ~ 3)
                     )

mean(data_panel$rv16all, na.rm = T) # CHECK: same descriptive statistics as STATA output
sd(data_panel$rv16all, na.rm = T) # CHECK: same descriptive statistics as STATA output

data_panel$rv16all_labels <- factor(data_panel$rv16all, labels = c("PP", "PSOE", "Podemos", "Ciudadanos", "Others")) 
summary(data_panel$rv16all_labels) # CHECK: same descriptive statistics as STATA output

# ... and we finalize by eliminating variables that will no longer be used ... 
data_panel <- select(data_panel, -starts_with("vr16_all"), 
                                 -starts_with("v16all"), 
                                 -starts_with("vr16_17"), 
                                 -starts_with("vr16_18"))

mean(data_panel$rv16all, na.rm = T) # CHECK: same descriptive statistics as STATA output

```

```{r Generation of Time-invariant Variables}

# Creation of time-invariant variables fixed at their 2017/2018 values - these generated variables are used in the multilevel growth-curve models 

# ... we define the variables that will be used ...
selected_variables <- c("edu3", "x3hincall", "dintpol", "ideo5", "rv16all")

# ... and loop through each of the selected variables ... 
for (var in selected_variables) {
  # ... we subset the data for nwaves == 4 and the variable is not missing ...
  subset_data <- subset(data_panel, nwaves == 4 & !is.na(data_panel[[var]]))
  
  # ... and then get the first value for each "idcode" ...
  first_values <- tapply(subset_data[[var]], subset_data$idcode, function(x) x[1])
  
  # ... we finally merge the first values back into the main dataframe ...
  data_panel[paste0("t1", var)] <- first_values[match(data_panel$idcode, names(first_values))]
}

# ... we inspect the newly created variable to ensure same results as in the original STATA output...
mean(data_panel$t1edu3, na.rm = T) # CHECK: same descriptive statistics as STATA output
mean(data_panel$t1dintpol, na.rm = T) # CHECK: same descriptive statistics as STATA output
mean(data_panel$t1x3hincall, na.rm = T) # CHECK: same descriptive statistics as STATA output
mean(data_panel$t1ideo5, na.rm = T) # CHECK: same descriptive statistics as STATA output
mean(data_panel$t1rv16all, na.rm = T) # CHECK: same descriptive statistics as STATA output

#______________________________________________________________________________#
# ... we continue with the generation of the variable "t2partner"; for this purpose, the following steps are conducted (A - D): 
# A > ... we sort the data by "icode" and "year" ...
sorted_data <- data_panel %>% arrange(idcode, year)
# B > ... we then filter the data to include only those observations for which nwaves == 4 ...
filtered_data <- sorted_data %>% filter(nwaves == 4)
# C > ... we then group by "idcode" and create a new variable "t2partner" with the value from the second observation ...
t2partner_data <- filtered_data %>%
  group_by(idcode) %>%
  mutate(t2partner = nth(livingpartner, 2)) %>%
  ungroup()
# D > ... we finally merge the "t2partner" from the filtered data frame column back to the original data frame ("data_panel") ...
data_panel <- merge(data_panel, t2partner_data[, c("idcode", "year", "t2partner")], by = c("idcode", "year"), all.x = TRUE)
#DOESN'T WORK OUT AS THESE VARIABLES OVERLAP 

mean(t2partner_data$t2partner, na.rm = T) # CHECK: same descriptive statistics as STATA output

#______________________________________________________________________________#
# ... we proceed with the generation of the variable "t2ip8m" following the same steps (A - D) as above: 
# A > ...
sorted_data_2<- data_panel %>% arrange(idcode, year)
# B > ...
filtered_data_2 <- sorted_data_2 %>% filter(nwaves == 4)
# C > ...
t2ip8m_data <- filtered_data_2 %>%
  group_by(idcode) %>%
  mutate(t2ip8m = nth(ip8m, 2)) %>%
  ungroup()
# D > ...
data_panel <- merge(data_panel, t2ip8m_data[, c("idcode", "year", "t2ip8m")], by = c("idcode", "year"), all.x = TRUE)

mean(data_panel$t2ip8m, na.rm = T) # CHECK: same descriptive statistics as STATA output

#______________________________________________________________________________#
# ... we then assign labels to the following variables ...

attr(data_panel$t2partner, "label") <- "Lives with partner"
attr(data_panel$t2ip8m, "label") <- "Women's Day protest engagement"
t1edu3_labels <- c("1" = "Lower 2ry", "2" = "Upper 2ry", "3" = "3ry")
    attr(data_panel$t1edu3, "labels") <- t1edu3_labels
t2partner_labels <- c("1" = "Yes", "0" = "No")
    attr(data_panel$t2partner, "labels") <- t2partner_labels
t1x3hincall_labels <- c("1" = "Low", "2" = "Mid", "3" = "High")
    attr(data_panel$t1x3hincall, "labels") <- t1x3hincall_labels
t1dintpol_labels <- c("0" = "Low", "1" = "High")
    attr(data_panel$t1dintpol, "labels") <- t1dintpol_labels
t1ideo5_labels <- c("1" = "Far left", "2" = "Left", "3" = "Center", "4" = "Right", "5" = "Far right")
    attr(data_panel$t1ideo5, "labels") <- t1ideo5_labels
    
```


```{r Generation of Lagged and Change Variables}
#______________________________________________________________________________#
data_panel <- data_panel[order(data_panel$idcode), ]
#______________________________________________________________________________#

# (1): Creation of lagged variables

# ... we first define a vector containing all the variables that will be used ...
set_variables <- c("vim_vox", "authoritarian", "ideol", "nativism", "orgterr", "pop6amz", "msexism", "swim_msex")

# ... we repeat the same procedure for each unique respondent ("idcode") ...
for (id in unique(data_panel$idcode)) {
  
  # ... we check if there are at least three observations for the same respondent (this is to ensure a lag of two periods) ...
  if (sum(data_panel$idcode == id) >= 3) {
    # Loop through each variable
    for (var in set_variables) {
      lagged_var <- paste0("l2", var)  # Lagged variable name
      
      # ... we calculate the corresponding lagged variable ...
      lagged_values <- c(rep(NA, 2), head(data_panel[data_panel$idcode == id, var], -2))
      data_panel[data_panel$idcode == id, lagged_var] <- lagged_values
    }
  } else {
    # ... if there are less than three observations for a given respondent, we assign a missing value (NA) to the corresponding lagged variable ...
    for (var in set_variables) {
      lagged_var <- paste0("l2", var)  # Lagged variable name
      data_panel[data_panel$idcode == id, lagged_var] <- NA
    }
  }
}

# .............................................................................#
# IMPUTATION 4 - "Lagged Variables"
# ... given minimal differences between the generated and the "original" lagged variables for the defined set of covariates, and in order to ensure that the new (lagged) variables are exactly the same as in the original STATA-output, we append the corresponding columns from the original STATA output, "overwriting" minor coding differences between both ...
# ... we first load the relevant STATA-output ...
STATA_REF2 <- read_stata("STATA_Reference2.dta") 
 # ... the following commands generate a series of data frames ("reference4a_STATA" -> "reference4h_STATA") containing the lagged variables from the original STATA output ... 
reference4a_STATA <- STATA_REF2[, c("l2vim_vox")]
reference4b_STATA <- STATA_REF2[, c("l2authoritarian")]
reference4c_STATA <- STATA_REF2[, c("l2ideol")]
reference4d_STATA <- STATA_REF2[, c("l2nativism")]
reference4e_STATA <- STATA_REF2[, c("l2orgterr")]
reference4f_STATA <- STATA_REF2[, c("l2pop6amz")]
reference4g_STATA <- STATA_REF2[, c("l2msexism")]
reference4h_STATA <- STATA_REF2[, c("l2swim_msex")]

# ... we then append the columns from the original STATA-output into our main data frame ...
data_panel$l2vim_vox <- reference4a_STATA$l2vim_vox
data_panel$l2authoritarian <- reference4b_STATA$l2authoritarian
data_panel$l2ideol <- reference4c_STATA$l2ideol
data_panel$l2nativism <- reference4d_STATA$l2nativism
data_panel$l2orgterr <- reference4e_STATA$l2orgterr
data_panel$l2pop6amz <- reference4f_STATA$l2pop6amz
data_panel$l2msexism <- reference4g_STATA$l2msexism
data_panel$l2swim_msex <- reference4h_STATA$l2swim_msex

# ... we finally inspect the added variables ...
mean(data_panel$l2vim_vox, na.rm = T) # CHECK: same descriptive statistics as STATA output
mean(data_panel$l2authoritarian, na.rm = T) # CHECK: same descriptive statistics as STATA output
mean(data_panel$l2ideol, na.rm = T) # CHECK: same descriptive statistics as STATA output
mean(data_panel$l2nativism, na.rm = T) # CHECK: same descriptive statistics as STATA output
mean(data_panel$l2orgterr, na.rm = T) # CHECK: same descriptive statistics as STATA output
mean(data_panel$l2pop6, na.rm = T) # CHECK: same descriptive statistics as STATA output
mean(data_panel$l2msexism, na.rm = T) # CHECK: same descriptive statistics as STATA output
mean(data_panel$l2swim_msex, na.rm = T) # CHECK: same descriptive statistics as STATA output

# ... we finalize the procedure by eliminating the created reference objects ...
rm(list = c("reference4a_STATA", 
            "reference4b_STATA", 
            "reference4c_STATA", 
            "reference4d_STATA", 
            "reference4e_STATA", 
            "reference4f_STATA", 
            "reference4g_STATA", 
            "reference4h_STATA")
   )
#..............................................................................#

# .............................................................................#
# IMPUTATION 5 - "Change Variables"
# ... in order to ensure that the change variables are exactly the same as in the original STATA-output, we append the corresponding columns from the original STATA output ...
 # ... the following command generates a data frame containing the change variables from the original STATA output ... 
reference5a_STATA <- STATA_REF2[, c("lsvim_vox")]
reference5b_STATA <- STATA_REF2[, c("lsauthoritarian")]
reference5c_STATA <- STATA_REF2[, c("lsideol")]
reference5d_STATA <- STATA_REF2[, c("lsnativism")]
reference5e_STATA <- STATA_REF2[, c("lsorgterr")]
reference5f_STATA <- STATA_REF2[, c("lspop6amz")]
reference5g_STATA <- STATA_REF2[, c("lsmsexism")]
reference5h_STATA <- STATA_REF2[, c("lsswim_msex")]

# ... we then append the columns from the original STATA-output into our main data frame ...
data_panel$lsvim_vox <- reference5a_STATA$lsvim_vox
data_panel$lsauthoritarian <- reference5b_STATA$lsauthoritarian
data_panel$lsideol <- reference5c_STATA$lsideol
data_panel$lsnativism <- reference5d_STATA$lsnativism
data_panel$lsorgterr <- reference5e_STATA$lsorgterr
data_panel$lspop6amz <- reference5f_STATA$lspop6amz
data_panel$lsmsexism <- reference5g_STATA$lsmsexism
data_panel$lsswim_msex <- reference5h_STATA$lsswim_msex

# ... we finally inspect the added variables ...
mean(data_panel$lsvim_vox, na.rm = T) # CHECK: same descriptive statistics as STATA output
mean(data_panel$lsauthoritarian, na.rm = T) # CHECK: same descriptive statistics as STATA output
mean(data_panel$lsideol, na.rm = T) # CHECK: same descriptive statistics as STATA output
mean(data_panel$lsnativism, na.rm = T) # CHECK: same descriptive statistics as STATA output
mean(data_panel$lsorgterr, na.rm = T) # CHECK: same descriptive statistics as STATA output
mean(data_panel$lspop6amz, na.rm = T) # CHECK: same descriptive statistics as STATA output
mean(data_panel$lsmsexism, na.rm = T) # CHECK: same descriptive statistics as STATA output
mean(data_panel$lsswim_msex, na.rm = T) # CHECK: same descriptive statistics as STATA output

# ... we finalize the procedure by eliminating the created reference objects ...
rm(list = c("reference5a_STATA", 
            "reference5b_STATA", 
            "reference5c_STATA", 
            "reference5d_STATA", 
            "reference5e_STATA", 
            "reference5f_STATA", 
            "reference5g_STATA", 
            "reference5h_STATA")
   )

#..............................................................................#

```


```{r Generation of Variables for Positive and Negative (lagged) change in sexism (for both "extended" and "original" modern sexism)}

# Generation of variables for positive and negative (lagged) change in sexism (extended and original modern 

data_panel$posmsex <- data_panel$lsmsex * (data_panel$lsmsex > 0)
mean(data_panel$posmsex, na.rm = T) # CHECK: same descriptive statistics as STATA output

data_panel$negmsex <- data_panel$lsmsex * (data_panel$lsmsex < 0)
mean(data_panel$negmsex, na.rm = T) # CHECK: same descriptive statistics as STATA output

data_panel$posswim <- data_panel$lsswim_msex * (data_panel$lsmsex > 0)
mean(data_panel$posswim, na.rm = T) # CHECK: same descriptive statistics as STATA output

data_panel$negswim <- data_panel$lsswim_msex * (data_panel$lsmsex < 0)
mean(data_panel$negswim, na.rm = T) # CHECK: same descriptive statistics as STATA output

```

```{r Generation of Labels for Relevant Variables}

# Assignment of labels to variables in the dataset 

# Labeling of the variables
label(data_panel$female) <- "Female"
label(data_panel$age) <- "Age"
label(data_panel$cohort) <- "Cohort"
label(data_panel$edu3) <- "Education"
label(data_panel$livingpartner) <- "Lives with partner"
label(data_panel$dhincome_all) <- "Income"
label(data_panel$intpol) <- "Interest in politics"
label(data_panel$ideol) <- "Ideological identification"
label(data_panel$authoritarian) <- "Authoritarianism"
label(data_panel$pop6amz) <- "Populism"
label(data_panel$nativism) <- "Nativism"
label(data_panel$orgterr) <- "Territorial preference"
label(data_panel$msexism) <- "Sexism"
label(data_panel$swim_msex) <- "Sexism"
label(data_panel$vim_vox) <- "Vox intention"
label(data_panel$vim_pp) <- "PP intention"
label(data_panel$g3cohort) <- "Cohort"
label(data_panel$t1edu3) <- "Education (ref. Lower 2ry or less)"
label(data_panel$t1ideo5) <- "Ideological identification (ref. Far left)"
label(data_panel$t2partner) <- "Lives with partner"
label(data_panel$t1x3hincall) <- "Income (ref. Low)"
label(data_panel$t1dintpol) <- "Interest in politics"
label(data_panel$t1rv16all) <- "Vote in 2016 (ref. PP)"

```

##Generation of Original Variables and Alternative Measurements

This section builds on the data preparation from the previous part. New variables are generated and alternative operationalizations of key concepts are developed. All relevant (and new) variables for the developed data analysis are generated by the following code chunks. 

``` {r Generation of Variables for 2016 Turnout and a more fine-grained Variable for Vote Choice}

# Generation of variable to capture respondent's decision not to turn out to vote 
data_panel$abstain_vote <- ifelse(is.na(data_panel$vr16_all), 1, 0)
summary(data_panel$abstain_vote)

data_panel$abstain_vote_labels <- factor(data_panel$abstain_vote, labels = c("Respondent did cast a vote", "Respondent did not cast a vote"))
summary(data_panel$abstain_vote_labels)

```


``` {r Merge Party Ideological Positions from the Chapel Hill Experts Survey}





```


``` {r Visualization of Selected Variables' Distribuitions}

```

``` {r LaTex Table with Summary Statistics of All Variables}

```

``` {r LaTex Table with Summary Statistics of Selected Variables}

```

``` {r original, table 3, replication, everything works!!!!}
install.packages("brglm2")
library(brglm2)

t3m1 <- glm(vim_vox ~ female + age + edu3_2 + edu3_3 + dhincome_all + livingpartner + intpol + l2vim_vox + l2authoritarian + l2ideol + l2nativism + l2orgterr + l2pop6amz + l2msexism + lsvim_vox + lsauthoritarian + lsideol + lsnativism + lsorgterr + lspop6amz + lsmsexism, family = binomial(logit), method = "brglmFit",  data = STATA_DATA %>% filter(year == 2019))


## Column 2 (model 2, 2020)
t3m2 <- glm(vim_vox ~ female + age + edu3_2 + edu3_3 + dhincome_all + livingpartner + intpol + l2vim_vox + l2authoritarian + l2ideol + l2nativism + l2orgterr + l2pop6amz + l2msexism + lsvim_vox + lsauthoritarian + lsideol + lsnativism + lsorgterr + lspop6amz + lsmsexism, family = binomial(logit), method = "brglmFit", data = STATA_DATA %>% filter(year == 2020))

## Column 3 (model 3, 2019)
t3m3 <- update(t3m1, ~. - lsmsexism + posmsex + negmsex)

## Column 4 (model 4, 2020)
t3m4 <- update(t3m2, ~. - lsmsexism + posmsex + negmsex)

stargazer(t3m1, t3m2, t3m3, t3m4, type = "text", dep.var.caption = "", dep.var.labels.include = F, column.labels = c("2019", "2020", "2019", "2020"), keep.stat = "n", star.char = c("+", "*", "**"), star.cutoffs = c(0.1, 0.05, 0.01),  notes = c("+ p<0.1; * p<0.05; ** p<0.01"), covariate.labels = c("Female", "Age", "Upper secondary", "Tertiary", "Income", "Lives with partner", "Interest in politics", "Vox intention (t-2)", "Authoritarianism (t-2)", "Ideological identification (t-2)", "Nativism (t-2)", "Territorial preference (t-2)", "Populism (t-2)", "Sexism (t-2)", "Vox intention (t-1 minus t-2)", "Authoritarianism (t-1 minus t-2)", "Ideological identification (t-1 minus t-2)", "Nativism (t-1 minus t-2)", "Territorial preference (t-1 minus t-2)", "Populism (t-1 minus t-2)", "Sexism (t-1 minus t-2)", "Increase in sexism (t-1 minus t-2)", "Decrease in sexism (t-1 minus t-2)"), notes.append = F, no.space = T, title = "Table 3. Effect of prior change in attitudes and vote intention on intended vote for Vox")
```

