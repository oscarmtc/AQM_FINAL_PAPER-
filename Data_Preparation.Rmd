---
title: "AQM Final Paper: Code for Replication and Extension of the Analysis"
author: "Ekaterina Leevik, Oscar Martinez, Elizabeth Sites"
date: ""
output:
  pdf_document:
    toc: no
    includes:
      in_header: header.tex
  # html_notebook:
    # toc: no
  html_document:
    toc: no
bibliography: 
---

```{r Initial Setup & Download of Required Packages, include=FALSE} 

# The first line sets an option for the final document that can be produced from
# the .Rmd file. Don't worry about it.
knitr::opts_chunk$set(echo = TRUE)

# The next bit (lines 22-43) is quite powerful and useful. 
# First you define which packages you need for your analysis and assign it to 
# the p_needed object. 
p_needed <-
  c("viridis", "knitr", "sandwich", "magrittr", "kableExtra", "MASS", "dplyr", "data.table", "margins", "readr", "plm", "Hmisc")

# Now you check which packages are already installed on your computer.
# The function installed.packages() returns a vector with all the installed 
# packages.
packages <- rownames(installed.packages())
# Then you check which of the packages you need are not installed on your 
# computer yet. Essentially you compare the vector p_needed with the vector
# packages. The result of this comparison is assigned to p_to_install.
p_to_install <- p_needed[!(p_needed %in% packages)]
# If at least one element is in p_to_install you then install those missing
# packages.
if (length(p_to_install) > 0) {
  install.packages(p_to_install)
}
# Now that all packages are installed on the computer, you can load them for
# this project. Additionally the expression returns whether the packages were
# successfully loaded.
sapply(p_needed, require, character.only = TRUE)

```


``` {r Load the main data source}

data <- fread("spanish_political_attitudes_dataset_2017_to_2020.csv")

# in order to use the "fread" function we first have to download the "data.table" package. This function is mainly employed for reading data from external files into R (in this case, the main data in in a csv format) in the form of data tables. It is especially useful when it comes to reading large datasets. 

dim(data) # we inspect the dimensions of the data: it has a total of 7850 observations (each observation corresponds to a panelist) and 37 variables. 

summary(data) # Overview of the data 

```

``` {r Code for the Preparation of the Data}

# This initial code chunk has the purpose of preparing the data for the latter statistical analysis. The preparation steps conducted stem from the replication material of "Sexism and the far-right vote: The individual dynamics of gender backlash." Although the initial replication code is available for STATA, we rewrite the code for R. Although some commands may be different and some steps may be either added or removed, the variables resulting (as well as their scales and coding schemes) should be exactly the same. 

#______________________________________________________________________________#
# (1): Generation of variable "idcode" 

data$idcode <- data$codpanelista2 
summary(data$idcode) # CHECK: same descriptive statistics as STATA output 

#______________________________________________________________________________#
#  (2): Generation of the variable "time" 

data$time <- data$wave - 9
data$time_labels <- factor(data$time, levels = 0:3, labels = c("2017", "2018", "2019", "2020"))
setorder(data, idcode, time_labels) # the "setorder()" function will  reorders the rows of the data table "data" based on the values of specified columns, in this case "idcode" and "time". This line of code will reorder the dataset in such a way that the rows are first sorted by the values in the "idcode" column, and within each unique value of "idcode", the rows are further sorted according to the values in the "time_labels" column.
summary(data$time) # CHECK: same descriptive statistics as STATA output 
summary(data$time_labels) # this is an additional factor variable created to assign the specific years to the "time" variable" 

#______________________________________________________________________________#
#  (3): Set the data to the panel data-format and sort according to "idcode"

# ... and we finaly set the dataset as panel data ...
data_panel <- pdata.frame(data, index = c("idcode", "time"))

# ... we also sort the dataset according to the variable "idcode" 
data_panel <- data_panel[order(data_panel$idcode), ]

#______________________________________________________________________________#
# (4): Generation of variable "nwaves"; this variable will indicate the total number of waves completed by each respondent (referred to by the variable "idcode")

# ... we first calculate the number of waves for each respondent ("idcode")
wave_counts <- data[, .N, by = idcode] # ... this line computes the count of observations (rows) for each unique value of "idcode" in the dataset ...
dim(wave_counts)
# ... we then merge the result back to the original dataset according to the variable "idcode"
data_panel <- merge(data_panel, wave_counts, by = "idcode", all.x = TRUE) # ... the "all.x = TRUE"-command specifies that all observations from the left dataset ("data") should be retained in the merged dataset, even if there are no matching observations in the right dataset ("wave_counts") ...
# ... we assign the count of observations to the "nwaves" variable
data_panel$nwaves <- data_panel$N 
# ... and finally remove the temporarily created "N" column
data_panel$N <- NULL
summary(data_panel$nwaves) # CHECK: same descriptive statistics as STATA output 

#______________________________________________________________________________#
# (5): Generation and assignments of values of variable "year"

data_panel$year <- data_panel$wave # the values which the variable "year" takes depend on the wave number specified by "wave"
data_panel$year[data_panel$year == 8] <- 2016 # ... this line assigns the value 2016 to the "year" variable in the dataset wherever the current value of "year" is equal to 8 ...
data_panel$year[data_panel$year == 9] <- 2017 # ... 
data_panel$year[data_panel$year == 10] <- 2018 # ... 
data_panel$year[data_panel$year == 11] <- 2019 # ... 
data_panel$year[data_panel$year == 12] <- 2020 # ... 
mean(data_panel$year) # CHECK: same descriptive statistics as STATA output 

#______________________________________________________________________________#
# (6): Generation of a dichotomous variable "female"; it takes the value of 1 whenever the respondent is female and 0 otherwise. 

data_panel$female <- ifelse(data_panel$sex == 2, 1, 0)
summary(data_panel$female) # CHECK: same descriptive statistics as STATA output 

#______________________________________________________________________________#
# (7): Creation of variable "age4"; this variable assigns a category to each respondent based on their age (given by "age")

data_panel$age4 <- cut(data_panel$age, breaks = c(16, 25, 35, 45, 100), labels = FALSE) # ... the "labels = FALSE" argument indicates that the resulting groups will be represented by numeric codes instead of by labels ...
data_panel$age4_labels <- factor(data_panel$age4, levels = 1:4, labels = c("16-25", "26-35", "36-45", "46+")) # this factor variable specifies the respondent's age group
summary(data_panel$age4) # CHECK: same summary statistics as STATA output 

#______________________________________________________________________________#
# (8): Generation of the variables for different cohorts 

# ... we initiate with the creation of the variable "coh0" ...
data_panel$coh0 <- ifelse(data_panel$wave == 9, data_panel$age, NA_real_)
mean(data_panel$coh0, na.rm = TRUE) # CHECK: same initial descriptive statistics as STATA output 

# ... we then generate the variable "coh1" ...
data_panel <- data_panel %>%
  group_by(idcode) %>%
  mutate(coh1 = sum(coh0, na.rm = TRUE)) %>%
  ungroup()
# ... we replace values of 0 for NA's ...
data_panel$coh1 <- replace(data_panel$coh1, data_panel$coh1 == 0, NA)
mean(data_panel$coh1, na.rm = TRUE) # CHECK: same initial descriptive statistics as STATA output 

#______________________________________________________________________________#
data_panel <- data_panel[order(data_panel$idcode), ]
#______________________________________________________________________________#

# ... we then replace values for the variable "coh1" ...
data_panel$coh1 <- ifelse(data_panel$wave == 10, data_panel$age - 1, data_panel$coh1)
summary(data_panel$coh1) # CHECK: STATA mean: 38.72556  !!!!!!!!!!!!!!!!!!!!!!!

# ... we then generate a new variable called "coh2" ...
data_panel <- data_panel %>%
  group_by(idcode) %>%
  mutate(coh2 = mean(coh1, na.rm = TRUE))
mean(data_panel$coh2, na.rm = T) # CHECK: STATA mean slightly different (38.39091)

# ... some values of "coh2" are replaced ... 
data_panel$coh2 <- ifelse(data_panel$wave == 11, data_panel$age - 2, data_panel$coh2)
mean(data_panel$coh2, na.rm = T) # CHECK: STATA mean slightly different (38.39685)

# ... we proceed with the creation of a variable called "coh23" ...
data_panel <- data_panel %>%
  group_by(idcode) %>%
  mutate(coh3 = mean(coh2, na.rm = TRUE))
mean(data_panel$coh3, na.rm = T) # CHECK: STATA mean slightly different (38.39897)

# ... some values of "coh3" are replaced ... 
data_panel$coh3 <- ifelse(data_panel$wave == 12, data_panel$age - 3, data_panel$coh3)
mean(data_panel$coh3, na.rm = T) # CHECK: STATA mean slightly different (38.2921)

# ... we then generate a new variable called "coh4" ...
data_panel <- data_panel %>%
  group_by(idcode) %>%
  mutate(coh4 = mean(coh3, na.rm = TRUE))
mean(data_panel$coh4, na.rm = T) # CHECK: STATA mean slightly different (38.2921)

# ... a new variable ("cohort") is created ... 
data_panel$cohort <- data_panel$coh4
summary(data_panel$cohort) # CHECK: STATA mean slightly different (38.2921)

# ... we eliminate the variables "coh0", "coh1", "coh2", "coh3", and "coh4" ...
data_panel$coh0 <- NULL
data_panel$coh1 <- NULL
data_panel$coh2 <- NULL
data_panel$coh3 <- NULL
data_panel$coh4 <- NULL

# Recode cohort variable
data_panel$g3cohort <- cut(data_panel$cohort, breaks = c(15, 29, 44, 100), labels = FALSE)
summary(data_panel$g3cohort) # CHECK: STATA mean slightly different (2.107898 )
data_panel$g3cohort_labels <- factor(data_panel$g3cohort, levels = 1:3, labels = c("15-29", "30-44", "45+")) # this factor variable specifies the respondent's cohort group and is derived from the variable "g3cohort" 
summary(data_panel$g3cohort_labels) # CHECK: STATA's tabulation by group slightly different 
#______________________________________________________________________________#
# (9): Generation of variable "edu" (this new variable is based on the values for the already existing variable "education") + generation of dummy variables for different education levels 

data_panel$edu3 <- cut(data_panel$education, breaks = c(0, 4, 7, 11), labels = FALSE) # the "cut" function divides the values of the variable "education" into intervals; in this case, the intervals are set to (0, 4], (4, 7], and (7, 11].
data_panel$edu3_labels <- factor(data_panel$edu3, levels = c(1, 2, 3), labels = c("Lower secondary", "Upper secondary", "Tertiary")) # definition of labels for the three levels of education ...
summary(data_panel$edu3_labels) # CHECK: STATA's tabulation by educational is the same

# ... based on the previously generated "edu3_labels"-variable, we proceed to generate dummy variables for all three education labels in the data set ... 

# ... a dummy variable for lower education ...
data_panel$edu3_1 <- ifelse(data_panel$edu3_labels == "Lower secondary", 1, 0)
summary(data_panel$edu3_1) # CHECK: same summary statistics as in STATA output 

# ... a dummy variable for upper secondary education ...
data_panel$edu3_2 <- ifelse(data_panel$edu3_labels == "Upper secondary", 1, 0)
mean(data_panel$edu3_2) # CHECK: same summary statistics as in STATA output 

# ... a dummy variable for tertiary education ...
data_panel$edu3_3 <- ifelse(data_panel$edu3_labels == "Tertiary", 1, 0)
mean(data_panel$edu3_3) # CHECK: same summary statistics as in STATA output 

#______________________________________________________________________________#
# (10): Specification of labels for the variable "livingpartner" according to its numeric values. 

data_panel$livingpartner_labels <- factor(data_panel$livingpartner, labels = c("Lives with partner", "Does not live with partner")) 

#______________________________________________________________________________#
# (11): Generation of the variable for respondent's income 

#data$hincome_all <- replace(data$hhincome, data$hhincome == 99, NA)
#data <- data %>%
#  group_by(idcode) %>%
#  mutate(hincome_all = ifelse(is.na(hincome_all) & year == 2017, hincome_all[year == 2017],
#                       ifelse(is.na(hincome_all) & year == 2018, hincome_all[year == 2018],
#                       ifelse(is.na(hincome_all) & year == 2019, hincome_all[year == 2019],
#                       ifelse(is.na(hincome_all) & year == 2020, hincome_all[year == 2020],
#                       hincome_all))))) %>%
#  ungroup() #no
#
#data$x3hincall <- cut(data$hincome_all, breaks = c(0, 5, 8, 12), labels = FALSE)
#data$dhincome_all <- cut(data$hincome_all, breaks = c(0, 5, 8, 12), labels = FALSE)

#______________________________________________________________________________#
# (12): Generation of two variables for the respondent's interest in politics

data_panel$intpol <- (4 - data_panel$polintr) / 3 # the variable "intpol" will range between 0 and 1, with values closer to 1 indicating a stronger interest in politics 
mean (data_panel$intpol) # CHECK: same descriptive statistics as STATA output 

data_panel$dintpol <- ifelse(data$polintr %in% c(1, 2), 1, 0) # second created variable -> "dintpol; some notes regarding the code used: 
    # data$polintr %in% c(1, 2) -> This condition checks if each value in the "polintr" variable is either 1 or 2
    # If the condition is TRUE (i.e., if the value in "polintr" is 1 or 2), "dintpol" is assigned a value of 1; on the other hand, if the condition is FALSE (i.e., if the value for "polintr" is neither 1 nor 2), "dintpol" is coded as 0.
data_panel$dintpol_labels <- factor(data_panel$dintpol, labels = c("Hardly or not at all", "Quite or very")) 
summary(data_panel$dintpol_labels) # CHECK: same descriptive statistics as STATA output 

#______________________________________________________________________________#
# (13): Generation of two variables for the respondent's ideological identification

data_panel$ideol <- data_panel$lrself / 10 # the variable "ideol" will range between 0 and 1, with values closer to 1 indicating a right-leaned position ... 
summary(data_panel$ideol) # CHECK: same descriptive statistics as STATA output 

data_panel$ideo5 <- ifelse(data_panel$lrself %in% 0:2, 1,
                    ifelse(data_panel$lrself %in% 3:4, 2,
                    ifelse(data_panel$lrself == 5, 3,
                    ifelse(data_panel$lrself %in% 6:7, 4,
                    ifelse(data_panel$lrself %in% 8:10,5, NA))))) # second created variable -> "ideo5" based the value of the already existing variable "lrself"; this variable assigns a value to each of the five defined intervals for the variable "lrself"

# ... we finally create a factor variable to label the different numeric values of "ideo5" ...
data_panel$ideo5_labels <- factor(data_panel$ideo5, labels = c("Far left", "Center left", "Center", "Center right", "Far right")) 
summary(data_panel$ideo5_labels) # CHECK: same descriptive statistics as STATA output

#______________________________________________________________________________#
# (14): Generation of variables to measure respondent's level of authoritarianism 

data_panel$a_respect <- ifelse(data_panel$indeprespect == 2, 1, 0) # first created variable -> "a_respect" based the value of the already existing variable "indeprespect"
mean(data_panel$a_respect) # CHECK: same descriptive statistics as STATA output 

data_panel$a_manner <- ifelse(data_panel$curiosmanners == 2, 1, 0) # second created variable -> "a_manner" based the value of the already existing variable "curiosmanners"
mean(data_panel$a_manner) # CHECK: same descriptive statistics as STATA output 

data_panel$a_behave <- ifelse(data_panel$empathybehave == 2, 1, 0) # third created variable -> "a_behave" based the value of the already existing variable "empathybehave"
mean(data_panel$a_behave) # CHECK: same descriptive statistics as STATA output 

data_panel$a_obedient <- ifelse(data_panel$selfconfobed == 1, 1, 0) # fourth created variable -> "a_obedient" based the value of the already existing variable "selfconfobed"
mean(data_panel$a_obedient) # CHECK: same descriptive statistics as STATA output 

data_panel$authoritarian <- rowMeans(data_panel[, c("a_respect", "a_manner", "a_behave", "a_obedient")]) # fifth created variable -> "authoritarian"; each observation for this new variable stems from the row means of the variables "a_respect", "a_manner", "a_behave", and "a_obedient"; the function "rowMeans()" calculates the mean value across the specified columns (in this case, each specified column refers to a single variable) for each of the rows in the data set.
mean(data_panel$authoritarian) # CHECK: same descriptive statistics as STATA output 

#______________________________________________________________________________#
# (15): Generation of variables to measure respondent's nativism

data_panel$natveco <- (10 - data_panel$immigeco) / 10 # this creates a variable ranging from 0 to 1, where values closer to 1 refer to a more negative attitude towards immigrant's effect of the economy 
mean(data_panel$natveco) # CHECK: same descriptive statistics as STATA output 

data_panel$natvcult <- data_panel$immicult / 10 # second created variable "natvcult" will range from 0 10 1, where values closer to 1 indicate that respondents believe that immigrants should have the same culture and customs as natives 
mean(data_panel$natvcult) # CHECK: same descriptive statistics as STATA output 

data_panel$nativism <- rowMeans(data_panel[, c("natveco", "natvcult")]) # third created variable "nativism" referring to the row means of the variables "natveco" and "natvcult". 
mean(data_panel$nativism) # CHECK: same descriptive statistics as STATA output 

#______________________________________________________________________________#
# (16): Generation of variables to measure respondent's level of populism 

# ... creation of a vector containing all the relevant variables
populism_vars <- c("populisma", "populismd", "populismf", "populismi", "populismj", "populismn")
# ... we generate a loop in order to iterate the following procedure for each of the variables in the vector "pop_vars" (created above) ...
for (var in populism_vars) {
  # ... the "paste0("ip_", var)" command will generate a new variable by appending the prefix "ip_" to the current variable name (to be able to use the "paste0()", we need the "dplyr" package)
  data_panel <- mutate(data_panel, !!paste0("ip_", var) := (get(var) - 1) / 6)
}
# ... and finally calculate the row means for each of the "ip_pop" variables and store these in a new variable called "pop6amz" ...
data_panel$pop6amz <- rowMeans(data_panel[grep("^ip_pop", names(data_panel))])
mean(data_panel$pop6amz) # CHECK: same descriptive statistics as STATA output 

#______________________________________________________________________________#
# (17): Generation of variables to measure territorial preferences 

data_panel$orgterr <- (data_panel$constpref - 1) / 4 # new variable "orgterr" based on the value of "constpref" is created, ranging between 0 and 1 ... 
mean(data_panel$orgterr) # CHECK: same descriptive statistics as STATA output 

#______________________________________________________________________________#
data_panel <- data_panel[order(data_panel$idcode), ]
#______________________________________________________________________________#
# (18): Generation of variables to measure respondent's modern sexism 

# ... we initially create new variables ("imsex_1a" though "imsex_9i") corresponding to the values of the already existing variable "femindexa" though "femindexi" ...
data_panel$imsex_1a <- data_panel$femindexa
data_panel$imsex_2b_t <- data_panel$femindexb
data_panel$imsex_3c <- data_panel$femindexc
data_panel$imsex_4d <- data_panel$femindexd
data_panel$imsex_5e <- data_panel$femindexe
data_panel$imsex_6f_t <- data_panel$femindexf
data_panel$imsex_7g_t <- data_panel$femindexg
data_panel$imsex_8h <- data_panel$femindexh
data_panel$imsex_9i <- data_panel$femindexi

# ... we then examine the class of the newly generated variables ...
class(data_panel$imsex_1a)
class(data_panel$imsex_2b_t)
class(data_panel$imsex_3c)
class(data_panel$imsex_4d)
class(data_panel$imsex_5e)
class(data_panel$imsex_6f_t)
class(data_panel$imsex_7g_t)
class(data_panel$imsex_8h)
class(data_panel$imsex_9i)

# ... and modify their class to ensure that they are all of the type "numeric" ...
data_panel$imsex_1a <- as.numeric(data_panel$imsex_1a)
data_panel$imsex_2b_t <- as.numeric(data_panel$imsex_2b_t)
data_panel$imsex_3c <- as.numeric(data_panel$imsex_3c)
data_panel$imsex_4d <- as.numeric(data_panel$imsex_4d)
data_panel$imsex_5e <- as.numeric(data_panel$imsex_5e)
data_panel$imsex_6f_t <- as.numeric(data_panel$imsex_6f_t)
data_panel$imsex_7g_t <- as.numeric(data_panel$imsex_7g_t)
data_panel$imsex_8h <- as.numeric(data_panel$imsex_8h)
data_panel$imsex_9i <- as.numeric(data_panel$imsex_9i)

# ... we proceed to modify the values of some of the variables "imsex_2b_t", "imsex_6f_t", "imsex_7g_t", and store the new values as "imsex_2b", "imsex_6f", and "imsex_7g" respectively. ... 
# ... we first recode "imsex_2b" ...
data_panel$imsex_2b <- NA # we first generate an "empty" variable 
data_panel <- mutate(data_panel,
                     imsex_2b = case_when(
                       imsex_2b_t == 1 ~ 7, 
                       imsex_2b_t == 2 ~ 6,
                       imsex_2b_t == 3 ~ 5,
                       imsex_2b_t == 4 ~ 4,
                       imsex_2b_t == 5 ~ 3,
                       imsex_2b_t == 6 ~ 2,
                       imsex_2b_t == 7 ~ 1
                       )
                     )
# ... we then recode "imsex_6f" ...
data_panel$imsex_6f <- NA # we first generate an "empty" variable 
data_panel <- mutate(data_panel,
                     imsex_6f = case_when(
                       imsex_6f_t == 1 ~ 7, 
                       imsex_6f_t == 2 ~ 6,
                       imsex_6f_t == 3 ~ 5,
                       imsex_6f_t == 4 ~ 4,
                       imsex_6f_t == 5 ~ 3,
                       imsex_6f_t == 6 ~ 2,
                       imsex_6f_t == 7 ~ 1
                       )
                     )
# ... and finally "imsex_7g" ...
data_panel$imsex_7g <- NA # we first generate an "empty" variable 
data_panel <- mutate(data_panel,
                     imsex_7g = case_when(
                       imsex_7g_t == 1 ~ 7, 
                       imsex_7g_t == 2 ~ 6,
                       imsex_7g_t == 3 ~ 5,
                       imsex_7g_t == 4 ~ 4,
                       imsex_7g_t == 5 ~ 3,
                       imsex_7g_t == 6 ~ 2,
                       imsex_7g_t == 7 ~ 1
                       )
                     )

mean(data_panel$imsex_2b) # CHECK: same descriptive statistics as STATA output 
mean(data_panel$imsex_6f) # CHECK: same descriptive statistics as STATA output 
mean(data_panel$imsex_7g) # CHECK: same descriptive statistics as STATA output 
mean(data_panel$imsex_1a) # CHECK: same descriptive statistics as STATA output 
mean(data_panel$imsex_3c) # CHECK: same descriptive statistics as STATA output 
mean(data_panel$imsex_4d) # CHECK: same descriptive statistics as STATA output  
mean(data_panel$imsex_5e) # CHECK: same descriptive statistics as STATA output  
mean(data_panel$imsex_8h) # CHECK: same descriptive statistics as STATA output 
mean(data_panel$imsex_9i) # CHECK: same descriptive statistics as STATA output 

# ... we then compute the row mean of variables starting with the string "imsex_" and store the estimated value in a new variable called "msexism" ... 
data_panel$msexism <- rowMeans(data_panel[, c("imsex_2b", "imsex_6f", "imsex_7g","imsex_1a","imsex_3c","imsex_4d","imsex_5e","imsex_8h", "imsex_9i")])

# ... we finally rescale the newly created variable "msexism" ... 
data_panel$msexism <- (data_panel$msexism - 1) / 6
mean(data_panel$msexism) # CHECK: same descriptive statistics as STATA output 

#______________________________________________________________________________#
# (19): Variable for modern sexism according to Swim et al. (1995)

# ... we first calculate row mean of the variables imsex_1 through imsex_8 ... 
data_panel$swim_msex <- rowMeans(data_panel[, c("imsex_1a", "imsex_2b", "imsex_3c", "imsex_4d", "imsex_5e", "imsex_6f", "imsex_7g", "imsex_8h" )])
mean(data_panel$swim_msex) #  CHECK: same descriptive statistics as STATA output 

# ... and then rescale values of the created variable "swim_msex" ...
data_panel$swim_msex <- (data_panel$swim_msex - 1) / 6
mean(data_panel$swim_msex) # CHECK: same descriptive statistics as STATA output 

#______________________________________________________________________________#
# (20): Generation of variables for respondent's engagement in Women's Day protests 

# ... we first dichotomize the variables "femstrike", "femdemonstrate", "feminfo", "femtalk", and generate corresponding new binary variables for each ... 

data_panel$p8m_strike <- ifelse(data_panel$femstrike == 1, 1, 0) # first variable created -> "p8m_strike"
mean(data_panel$p8m_strike, na.rm = T) # CHECK: same descriptive statistics as STATA output 
data_panel$p8m_demonst <- ifelse(data_panel$femdemonstrate == 1, 1, 0) # second variable created -> "p8m_demonst"
mean(data_panel$p8m_demonst, na.rm = T) # CHECK: same descriptive statistics as STATA output 

data_panel$p8m_mobiliz <- ifelse(data_panel$feminfo == 1, 1, 0) # third variable created -> "p8m_mobiliz"
mean(data_panel$p8m_mobiliz, na.rm = T) # CHECK: same descriptive statistics as STATA output 

data_panel$p8m_talked <- ifelse(data_panel$femtalk == 1, 1, 0) # fourth variable created -> "p8m_talked"
mean(data_panel$p8m_talked, na.rm = T) # CHECK: same descriptive statistics as STATA output 
# ... and finally estimate the row mean for each observation out of the four generated variables above ... 
data_panel$ip8m <- rowMeans(data_panel[, c("p8m_strike", "p8m_demonst", "p8m_mobiliz", "p8m_talked")])
mean(data_panel$ip8m,na.rm = T) # CHECK: same descriptive statistics as STATA output 

#______________________________________________________________________________#
# (21): Respondent's intended vote for the Vox-party (MAIN DEPENDENT VARIABLE)

data_panel$vim_vox <- ifelse(data_panel$voteintentionspain == 23, 1, 0) # the values for the created binary variable ("vim_vox") are defined as a function of the values for the already existing variable "voteintentionspain" 
mean(data_panel$vim_vox)

# ... and we proceed with the generation of a corresponding factor variable ...
data_panel$vim_vox_labels <- factor(data_panel$vim_vox, labels = c("Else", "Vox")) 
summary(data_panel$vim_vox_labels) # CHECK: same descriptive statistics as STATA output

#______________________________________________________________________________#
# (22): Respondent's intended vote for the PP-party (PLACEBO DEPENDENT VARIABLE)

data_panel$vim_pp <- ifelse(data_panel$voteintentionspain == 2, 1, 0) # the values for the created binary variable ("vim_pp") are defined as a function of the values for the already existing variable "voteintentionspain" 
mean(data_panel$vim_pp) # CHECK: same descriptive statistics as STATA output

# ... and we proceed with the generation of a corresponding factor variable ...
data_panel$vim_pp_labels <- factor(data_panel$vim_pp, labels = c("Else", "PP")) 
summary(data_panel$vim_pp_labels) # CHECK: same descriptive statistics as STATA output

#______________________________________________________________________________#
# (23): Respondent's reported vote for the four largest parties in the 2016 election 

# Re-code 'vote2016' into 'vr16_all' variable
data_panel$vr16_all <- ifelse(data_panel$vote2016 == 1, 1,
                        ifelse(data_panel$vote2016 == 2, 2,
                        ifelse(data_panel$vote2016 %in% c(3, 5, 25), 3,
                        ifelse(data_panel$vote2016 == 4, 4,
                        ifelse(data_panel$vote2016 %in% 1:56, 0, NA)))))
summary(data_panel$vr16_all) # CHECK: same descriptive statistics as STATA output

data_panel$vr16_all_labels <- factor(data_panel$vr16_all, labels = c("Else", "PSOE", "PP", "Podemos", "Cs")) 
summary(data_panel$vr16_all_labels) # CHECK: same descriptive statistics as STATA output

#______________________________________________________________________________#
# Generation of variable to capture respondent's decision not to turn out to vote 

data_panel$abstain_vote <- ifelse(is.na(data_panel$vr16_all), 1, 0)
summary(data_panel$abstain_vote)
#______________________________________________________________________________#

# Generate 'vr16_17' and 'vr16_18' variables for the years 2017 and 2018 - this is because the vote choice was only asked in the 2017 and 2018 waves ...
data_panel$vr16_17 <- ifelse(data_panel$year == 2017, data_panel$vr16_all, NA_integer_)
mean(data_panel$vr16_17, na.rm=T) # CHECK: same descriptive statistics as STATA output

data_panel$vr16_18 <- ifelse(data_panel$year == 2018, data_panel$vr16_all, NA_integer_)
mean(data_panel$vr16_18, na.rm=T) # CHECK: same descriptive statistics as STATA output

# ... we proceed to generate the 'vr16_17a' and 'vr16_18a' variables by taking the maximum for value of "vr16_17" and "vr16_18" for each respondent ... 
data_panel <- data_panel %>%
  group_by(idcode) %>%
  mutate(vr16_17a = ifelse(all(is.na(vr16_17)), NA_integer_, max(vr16_17, na.rm = TRUE)),
         vr16_18a = ifelse(all(is.na(vr16_18)), NA_integer_, max(vr16_18, na.rm = TRUE)))
mean(data_panel$vr16_17a, na.rm=T) # CHECK: same descriptive statistics as STATA output
mean(data_panel$vr16_18a, na.rm=T) # CHECK: same descriptive statistics as STATA output

# ... we generate the 'v16all' variable based with the same values as "vr16_17a" ...
data_panel$v16all <- data_panel$vr16_17a
mean(data_panel$v16all, na.rm=T) # CHECK: same descriptive statistics as STATA output

# ... and continue with replacing the values in "v16all" with values from "vr16_18a" based on conditions ...
condition <- (data_panel$vr16_17a == 0 | is.na(data_panel$vr16_17a)) & !is.na(data_panel$vr16_18a)
data_panel$v16all[condition] <- data_panel$vr16_18a[condition]
mean(data_panel$v16all, na.rm = T) # CHECK: same descriptive statistics as STATA output

# ... and we then re-code the 'v16all' variable and store the new coding scheme in a new variable called "rv16all" ...
data_panel$v16all_t <- data_panel$v16all
data_panel$rv16all <- NA # we first generate an "empty" variable 

data_panel <- mutate(data_panel,
                     rv16all = case_when(
                       v16all == 0 ~ 4, 
                       v16all == 1 ~ 1,
                       v16all == 2 ~ 0,
                       v16all == 3 ~ 2,
                       v16all == 4 ~ 3)
                     )

mean(data_panel$rv16all, na.rm = T) # CHECK: same descriptive statistics as STATA output


data_panel$rv16all_labels <- factor(data_panel$rv16all, labels = c("PP", "PSOE", "Podemos", "Ciudadanos", "Others")) 
summary(data_panel$rv16all_labels) # CHECK: same descriptive statistics as STATA output

# ... and we finalize by eliminating variables that will no longer be used ... 
data_panel <- select(data_panel, -starts_with("vr16_all"), 
                                 -starts_with("v16all"), 
                                 -starts_with("vr16_17"), 
                                 -starts_with("vr16_18"))

mean(data_panel$rv16all, na.rm = T) # CHECK: same descriptive statistics as STATA output












#______________________________________________________________________________#
# (24): Creation of time-invariant variables fixed at their 2017/2018 values - these generated variables are used in the multilevel growth-curve models 
# NOTE: ADD INCOME VARIABLE "x3hincall" !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 

# ... we define the variables that will be used ...
selected_variables <- c("edu3", "dintpol", "ideo5", "rv16all")

# ... and loop through each of the selected variables ... 
for (var in selected_variables) {
  # ... we subset the data for nwaves == 4 and the variable is not missing ...
  subset_data <- subset(data_panel, nwaves == 4 & !is.na(data_panel[[var]]))
  
  # ... and then get the first value for each "idcode" ...
  first_values <- tapply(subset_data[[var]], subset_data$idcode, function(x) x[1])
  
  # ... we finally merge the first values back into the main dataframe ...
  data_panel[paste0("t1", var)] <- first_values[match(data_panel$idcode, names(first_values))]
}

# ... we inspect the newly created variable to ensure same results as in the original STATA output... 
mean(data_panel$t1edu3, na.rm = T) # CHECK: same descriptive statistics as STATA output
mean(data_panel$t1dintpol, na.rm = T) # CHECK: same descriptive statistics as STATA output
mean(data_panel$t1ideo5, na.rm = T) # CHECK: same descriptive statistics as STATA output
mean(data_panel$t1rv16all, na.rm = T) # CHECK: same descriptive statistics as STATA output

###############################################################################
# ... we continue with the generation of the variable "t2partner"; for this purpose, the following steps are conducted (A - D): 
# A > ... we sort the data by "icode" and "year" ...
sorted_data <- data_panel %>% arrange(idcode, year)
# B > ... we then filter the data to include only those observations for which nwaves == 4 ...
filtered_data <- sorted_data %>% filter(nwaves == 4)
# C > ... we then group by "idcode" and create a new variable "t2partner" with the value from the second observation ...
t2partner_data <- filtered_data %>%
  group_by(idcode) %>%
  mutate(t2partner = nth(livingpartner, 2)) %>%
  ungroup()
# D > ... we finally merge the "t2partner" from the filtered data frame column back to the original data frame ("data_panel") ...
data_panel <- merge(data_panel, t2partner_data[, c("idcode", "year", "t2partner")], by = c("idcode", "year"), all.x = TRUE)

mean(data_panel$t2partner, na.rm = T) # CHECK: same descriptive statistics as STATA output

###############################################################################
# ... we proceed with the generation of the variable "t2ip8m" following the same steps (A - D) as above: 
# A > ...
sorted_data_2<- data_panel %>% arrange(idcode, year)
# B > ...
filtered_data_2 <- sorted_data_2 %>% filter(nwaves == 4)
# C > ...
t2ip8m_data <- filtered_data_2 %>%
  group_by(idcode) %>%
  mutate(t2ip8m = nth(ip8m, 2)) %>%
  ungroup()
# D > ...
data_panel <- merge(data_panel, t2ip8m_data[, c("idcode", "year", "t2ip8m")], by = c("idcode", "year"), all.x = TRUE)

mean(data_panel$t2ip8m, na.rm = T) # CHECK: same descriptive statistics as STATA output

################################################################################ 
# ... we then assign labels to the following variables ...

attr(data_panel$t2partner, "label") <- "Lives with partner"
attr(data_panel$t2ip8m, "label") <- "Women's Day protest engagement"
t1edu3_labels <- c("1" = "Lower 2ry", "2" = "Upper 2ry", "3" = "3ry")
    attr(data_panel$t1edu3, "labels") <- t1edu3_labels
t2partner_labels <- c("1" = "Yes", "0" = "No")
    attr(data_panel$t2partner, "labels") <- t2partner_labels
t1dintpol_labels <- c("0" = "Low", "1" = "High")
    attr(data_panel$t1dintpol, "labels") <- t1dintpol_labels
t1ideo5_labels <- c("1" = "Far left", "2" = "Left", "3" = "Center", "4" = "Right", "5" = "Far right")
    attr(data_panel$t1ideo5, "labels") <- t1ideo5_labels
    
#______________________________________________________________________________#
data_panel <- data_panel[order(data_panel$idcode), ]
#______________________________________________________________________________#
# (25): Creation of lagged and change-variables
    
# ... we first define a vector containing all the variables that will be used ...
# Define the variables to use
variables_to_use <- c("vim_vox", "authoritarian", "ideol", "nativism", "orgterr", "pop6", "msexism", "swim_msex")

# Loop through each unique idcode
for (id in unique(data_panel$idcode)) {
  # Subset data for the current idcode
  subset_data <- data_panel[data_panel$idcode == id, ]
  
  # Check if there are at least two observations for the same idcode
  if (nrow(subset_data) >= 2) {
    # Loop through each variable
    for (var in variables_to_use) {
      lagged_var <- paste0("l2_", var)  # Lagged variable name
      
      # Calculate lagged variable
      subset_data[[lagged_var]] <- c(NA, head(subset_data[[var]], -1))
    }
  } else {
    # If less than two observations, assign NA for lagged variables
    for (var in variables_to_use) {
      lagged_var <- paste0("l2_", var)  # Lagged variable name
      subset_data[[lagged_var]] <- NA
    }
  }
  
  # ... we finally append the data subset to the original dataframe "data_panel" ...
  data_panel[data_panel$idcode == id, ] <- subset_data
}
# ... we inspect the generated variables to ensure that they are the same as those generated in the original STATA output ... 

mean(data_panel$l2_vim_vox, na.rm = T)
mean(data_panel$l2_authoritarian, na.rm = T)
mean(data_panel$l2_ideol, na.rm = T)
mean(data_panel$l2_nativism, na.rm = T)
mean(data_panel$l2_orgterr, na.rm = T)
mean(data_panel$l2_pop6amz, na.rm = T)
mean(data_panel$l2_msexism, na.rm = T)
mean(data_panel$l2_swim_msex, na.rm = T)

mean(data_panel$ls_vim_vox, na.rm = T)
mean(data_panel$ls_authoritarian, na.rm = T)
mean(data_panel$ls_ideol, na.rm = T)
mean(data_panel$ls_nativism, na.rm = T)
mean(data_panel$ls_orgterr, na.rm = T)
mean(data_panel$ls_pop6amz, na.rm = T)
mean(data_panel$ls_msexism, na.rm = T)
mean(data_panel$ls_swim_msex, na.rm = T)

# CHECK: same descriptive statistics as STATA output


#______________________________________________________________________________#
# (26): Generation of variables for positive and negative (lagged) change in sexism (extended and original modern 

data_panel$posmsex <- data_panel$lsmsex * (data_panel$lsmsex > 0)
summary(data_panel$posmsex) 

data_panel$negmsex <- data_panel$lsmsex * (data_panel$lsmsex < 0)
summary(data_panel$negmsex) 

data_panel$posswim <- data_panel$lsswim_msex * (data_panel$lsmsex > 0)
summary(data_panel$posswim) 

data_panel$negswim <- data_panel$lsswim_msex * (data_panel$lsmsex < 0)
summary(data_panel$negswim) 



#______________________________________________________________________________#
# (26): Assignment of labels to variables in the dataset 

# Labeling of the variables
label(data_panel$female) <- "Female"
label(data_panel$age) <- "Age"
label(data_panel$cohort) <- "Cohort"
label(data_panel$edu3) <- "Education"
label(data_panel$livingpartner) <- "Lives with partner"
#label(data_panel$dhincome_all) <- "Income"
label(data_panel$intpol) <- "Interest in politics"
label(data_panel$ideol) <- "Ideological identification"
label(data_panel$authoritarian) <- "Authoritarianism"
label(data_panel$pop6amz) <- "Populism"
label(data_panel$nativism) <- "Nativism"
label(data_panel$orgterr) <- "Territorial preference"
label(data_panel$msexism) <- "Sexism"
label(data_panel$swim_msex) <- "Sexism"
label(data_panel$vim_vox) <- "Vox intention"
label(data_panel$vim_pp) <- "PP intention"
label(data_panel$g3cohort) <- "Cohort"
label(data_panel$t1edu3) <- "Education (ref. Lower 2ry or less)"
label(data_panel$t1ideo5) <- "Ideological identification (ref. Far left)"
label(data_panel$t2partner) <- "Lives with partner"
#label(data_panel$t1x3hincall) <- "Income (ref. Low)"
label(data_panel$t1dintpol) <- "Interest in politics"
label(data_panel$t1rv16all) <- "Vote in 2016 (ref. PP)"

```


``` {r }



```
``` {r }



```

``` {r }



```

``` {r }



```

``` {r }



```

``` {r }



```

``` {r }



```

``` {r }



```

``` {r }



```

``` {r }



```

``` {r }



```

``` {r }



```

``` {r }



```

``` {r }



```





