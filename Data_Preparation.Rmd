---
title: "AQM Final Paper: Code for Replication and Extension of the Analysis"
author: "Ekaterina Leevik, Oscar Martinez Elizabeth Sites & Lukas"
date: ""
output:
  pdf_document:
    toc: no
    includes:
      in_header: header.tex
  # html_notebook:
    # toc: no
  html_document:
    toc: no
bibliography: hw3.bib
---

```{r Initial Setup & Download of Required Packages, include=FALSE}
# The first line sets an option for the final document that can be produced from
# the .Rmd file. Don't worry about it.
knitr::opts_chunk$set(echo = TRUE)

# The next bit (lines 22-43) is quite powerful and useful. 
# First you define which packages you need for your analysis and assign it to 
# the p_needed object. 
p_needed <-
  c("viridis", "knitr", "sandwich", "magrittr", "kableExtra", "MASS", "dplyr", "data.table", "margins")

# Now you check which packages are already installed on your computer.
# The function installed.packages() returns a vector with all the installed 
# packages.
packages <- rownames(installed.packages())
# Then you check which of the packages you need are not installed on your 
# computer yet. Essentially you compare the vector p_needed with the vector
# packages. The result of this comparison is assigned to p_to_install.
p_to_install <- p_needed[!(p_needed %in% packages)]
# If at least one element is in p_to_install you then install those missing
# packages.
if (length(p_to_install) > 0) {
  install.packages(p_to_install)
}
# Now that all packages are installed on the computer, you can load them for
# this project. Additionally the expression returns whether the packages were
# successfully loaded.
sapply(p_needed, require, character.only = TRUE)

```


``` {r Load the main data source}

library(readr)
data <- fread("spanish_political_attitudes_dataset_2017_to_2020.csv")

# in order to use the "fread" function we first have to download the "data.table" package. This function is mainly employed for reading data from external files into R (in this case, the main data in in a csv format) in the form of data tables. It is especially useful when it comes to reading large datasets. 

dim(data) # we inspect the dimensions of the data: it has a total of 7850 observations (each observation corresponds to a panelist) and 37 variables. 

# We additionally inspect Whether there are any missing values across the columns and rows constituting the dataset. This is relevant for the latter optimization steps. 
any(is.na(data))

summary(data) # Overview of the data 

```

``` {r Code for the Preparation of the Data}

# This initial code chunk has the purpose of preparing the data for the latter statistical analysis. The preparation steps conducted stem from the replication material of "Sexism and the far-right vote: The individual dynamics of gender backlash." Although the initial replication code is available for STATA, we rewrite the code for R. Although some commands may be different and some steps may be either added or removed, the variables resulting (as well as their scales and coding schemes) should be exactly the same. 

#______________________________________________________________________________#
# (1): Change the label for "codpanelista2"
data$idcode <- data$codpanelista2

#______________________________________________________________________________#
#  (2): Generation of the variable "time" 
data$time <- data$wave - 9
data$time <- factor(data$time, levels = 0:3, labels = c("2017", "2018", "2019", "2020"))
setorder(data, idcode, time) # the setorder() function will  reorders the rows of the data table "data" based on the values of specified columns, in this case "idcode" and "time". This line of code will reorder the dataset in such a way that the rows are first sorted by the values in the "idcode" column, and within each unique value of "idcode", the rows are further sorted according to the values in the "time" column.

#______________________________________________________________________________#

#____________________________________
#QUESTION: Panel setting in R?
#xtset idcode time
#____________________________________
# (3): Generation of variable "nwaves"; this variable will indicate the total number of waves completed by each respondent (referred to by the variable "idcode")

# ... we first calculate the number of waves for each respondent ("idcode")
wave_counts <- data[, .N, by = idcode]
dim(wave_counts)
# ... we then merge the result back to the original dataset according to the variable "idcode"
data <- merge(data, wave_counts, by = "idcode", all.x = TRUE)
# ... we assign the count of observations to the "nwaves" variable
data$nwaves <- data$N
# ... and finally remove the temporarily created "N" column
data$N <- NULL
# To finalize the generation of the new variable "nwaves", we add on unit to all observations. 
data$nwaves <- data$nwaves + 1  # WHY + 1 ??

#______________________________________________________________________________#
# (4): Generation and assignments of values of variable "year"
data$year <- data$wave # the values which the variable "year" takes depend on the wave number specified by "wave"
data$year[data$year == 8] <- 2016
data$year[data$year == 9] <- 2017
data$year[data$year == 10] <- 2018
data$year[data$year == 11] <- 2019
data$year[data$year == 12] <- 2020

#______________________________________________________________________________#

# (5): Generation of a dichotomous variable "female"; it takes the value of 1 whenever the respondent is female and 0 otherwise. 
data$female <- ifelse(data$sex == 2, 1, 0)

#______________________________________________________________________________#
# (6): Creation of variable "age_group"; this variable assigns a category to each respondent based on their age (given by "age")
data$age_group <- cut(data$age, breaks = c(15, 25, 35, 45, 100), labels = FALSE)

#______________________________________________________________________________#
# (7): Generation of the variables for different cohorts 
#
#library(dplyr)
#
# Create coh0 column
#data <- data %>%
#  mutate(coh0 = ifelse(wave == 9, age, NA))
#
# Create coh1 column
#data <- data %>%
#  group_by(idcode) %>%
#  mutate(coh1 = sum(coh0, na.rm = TRUE))
# ... and replace coh1 values where wave = 10 and coh1 == NA
#data <- data %>%
#  mutate(coh1 = ifelse(wave == 10 & is.na(coh1), age - 1, coh1))
#
# Create coh2 column
#data <- data %>%
#  group_by(idcode) %>%
#  mutate(coh2 = mean(coh1, na.rm = TRUE))
# ... and replace coh2 values where wave == 11 and coh2 is missing or NA
#data <- data %>%
#  mutate(coh2 = ifelse(wave == 11 & is.na(coh2), age - 2, coh2))
#
# Create coh3 column
#data <- data %>%
#  group_by(idcode) %>%
#  mutate(coh3 = mean(coh2, na.rm = TRUE))
# ... and replace coh3 values where wave == 12 and coh3 is missing or NA
#data <- data %>%
#  mutate(coh3 = ifelse(wave == 12 & is.na(coh3), age - 3, coh3))
#
# Create coh4 column
#data <- data %>%
#  group_by(idcode) %>%
#  mutate(coh4 = mean(coh3, na.rm = TRUE))
#
# Create cohort column
#data <- data %>%
#  mutate(cohort = coh4)
#
# Drop intermediate columns
#data <- data %>%
#  select(-coh0, -coh1, -coh2, -coh3, -coh4)
#
# Recode cohort column
#data <- data %>%
#  mutate(g3cohort = case_when(
#    cohort >= 15 & cohort <= 29 ~ 1,
#    cohort >= 30 & cohort <= 44 ~ 2,
#    cohort >= 45 ~ 3
#  ))

#______________________________________________________________________________#
# (8): Generation of variable "edu"; this new variable is based on the values for the already existing variable "education"

data$edu3 <- cut(data$education, breaks = c(0, 4, 7, 11), labels = FALSE) # the "cut" function divides the values of the variable "education" into intervals; in this case, the intervals are set to (0, 4], (4, 7], and (7, 11].
data$edu3_ <- factor(data$edu3) # This generates a dummy variable for each of the categories of the variable "edu3" generated above. 

#______________________________________________________________________________#
# (9): Specification of labels for the variable "livingpartner" according to its numeric values. 

data$livingpartner <- factor(data$livingpartner, labels = c("Lives with partner", "Does not live with partner"))

#______________________________________________________________________________#



# (10): 


data$hincome_all <- replace(data$hhincome, data$hhincome == 99, NA)
data$hincome_all <- ifelse(is.na(data$hincome_all),
                           ifelse(data$year == 2017, data$hincome_all[data$year == 2018],
                                  ifelse(data$year == 2018, data$hincome_all[data$year == 2017],
                                         ifelse(data$year == 2019, data$hincome_all[data$year == 2020],
                                                ifelse(data$year == 2020, data$hincome_all[data$year == 2019], NA))))), by = idcode

data$x3hincall <- cut(data$hincome_all, breaks = c(0, 5, 8, 12), labels = FALSE)
data$dhincome_all <- cut(data$hincome_all, breaks = c(0, 5, 8, 12), labels = FALSE)


#______________________________________________________________________________#
# (11): Generation of two variables for the respondent's interest in politics

data$intpol <- (4 - data$polintr) / 3 # first created variable -> "intpol"
data$dintpol <- ifelse(data$polintr %in% c(1, 2), 1, 0) # second created variable -> "dintpol; some notes regarding the code used: 
    # data$polintr %in% c(1, 2) -> This condition checks if each value in the "polintr" variable is either 1 or 2
    # If the condition is TRUE (i.e., if the value in "polintr" is 1 or 2), "dintpol" is assigned a value of 1; on the other hand, if the condition is FALSE (i.e., if the value for "polintr" is neither 1 nor 2), "dintpol" is coded as 0.
       
#______________________________________________________________________________#
# (12): Generation of two variables for the respondent's ideological identification

data$ideol <- data$lrself / 10 # first created variable -> "ideol" based the value of the already existing variable "lrself"
data$ideo5 <- cut(data$lrself, breaks = c(0, 2, 4, 5, 7, 10), labels = FALSE) # second created variable -> "ideo5" based the value of the already existing variable "lrself"; this variable assigns a value to each of the five defined intervals for the variable "lrself"

#______________________________________________________________________________#
# (13): Generation of variables to measure respondent's level of authoritarianism 

data$a_respect <- ifelse(data$indeprespect == 2, 1, 0) # first created variable -> "a_respect" based the value of the already existing variable "indeprespect"

data$a_manner <- ifelse(data$curiosmanners == 2, 1, 0) # second created variable -> "a_manner" based the value of the already existing variable "curiosmanners"

data$a_behave <- ifelse(data$empathybehave == 2, 1, 0) # third created variable -> "a_behave" based the value of the already existing variable "empathybehave"

data$a_obedient <- ifelse(data$selfconfobed == 1, 1, 0) # fourth created variable -> "a_obedient" based the value of the already existing variable "selfconfobed"

data$authoritarian <- rowMeans(data[, c("a_respect", "a_manner", "a_behave", "a_obedient")]) # fifth created variable -> "authoritarian"; each observation for this new variable stems from the row means of the variables "a_respect", "a_manner", "a_behave", and "a_obedient"; the function "rowMeans()" calculates the mean value across the specified columns (in this case, each specified column refers to a single variable) for each of the rows in the data set.

#______________________________________________________________________________#
# (14): Generation of variables to measure respondent's nativism

data$natveco <- (10 - data$immigeco) / 10 # first created variable "natveco"
data$natvcult <- data$immicult / 10 # second created variable "natvcult"
data$nativism <- rowMeans(data[, c("natveco", "natvcult")]) # third created variable "nativism" referring to the row means of the variables "natveco" and "natvcult". 





#______________________________________________________________________________#
# (15): Generation of variables to measure respondent's level of populism 

library(dplyr)

# ... creation of a vector containing all the relevant variables
pop_vars <- c("populisma", "populismd", "populismf", "populismi", "populismj", "populismn")
# ... we generate a loop in order to iterate the following procedure for each of the variables in the vector "pop_vars" (created above) ...
for (var in pop_vars) {
  # ... the "paste0("ip_", var)" command will generate a new variable by appending the prefix "ip_" to the current variable name (to be able to use the "paste0()", we need the "dplyr" package)
  data <- mutate(data, !!paste0("ip_", var) := (get(var) - 1) / 6)
}
# ... we finally calculate Calculate the row mean of rescaled variables
data <- mutate(data, pop6amz = rowMeans(select(data, starts_with("ip_pop"))))

#______________________________________________________________________________#
# (16): Generation of variables to measure territorial preferences 

data$orgterr <- (data$constpref - 1) / 4 # new variable "orgterr" based on the value of "constpref"

#______________________________________________________________________________#
# (17): Generation of variables to measure respondent's modern sexism 

# ... we initially create new variables ("imsex_1a" though "imsex_9i") corresponding to the values of the already existing variable "femindexa" though "femindexi" ...
data <- mutate(data,
               imsex_1a = femindexa,
               imsex_2b = femindexb,
               imsex_3c = femindexc,
               imsex_4d = femindexd,
               imsex_5e = femindexe,
               imsex_6f = femindexf,
               imsex_7g = femindexg,
               imsex_8h = femindexh,
               imsex_9i = femindexi)
# ... we proceed to modify the values of some of the variables generated above ... 
data <- mutate(data,
               imsex_2b = case_when(imsex_2b == 1 ~ 7,
                                    imsex_2b == 2 ~ 6,
                                    imsex_2b == 3 ~ 5,
                                    imsex_2b == 4 ~ 4,
                                    imsex_2b == 5 ~ 3,
                                    imsex_2b == 6 ~ 2,
                                    imsex_2b == 7 ~ 1),
               imsex_6f = case_when(imsex_6f == 1 ~ 7,
                                    imsex_6f == 2 ~ 6,
                                    imsex_6f == 3 ~ 5,
                                    imsex_6f == 4 ~ 4,
                                    imsex_6f == 5 ~ 3,
                                    imsex_6f == 6 ~ 2,
                                    imsex_6f == 7 ~ 1),
               imsex_7g = case_when(imsex_7g == 1 ~ 7,
                                    imsex_7g == 2 ~ 6,
                                    imsex_7g == 3 ~ 5,
                                    imsex_7g == 4 ~ 4,
                                    imsex_7g == 5 ~ 3,
                                    imsex_7g == 6 ~ 2,
                                    imsex_7g == 7 ~ 1))
# ... we then compute the row mean of variables starting with the string "imsex_" and store the estimated value in a new variable called "msexism" ... 
data <- mutate(data, msexism = rowMeans(select(data, starts_with("imsex_"))))
# ... we finally rescale the newly created variable "msexism" ... 
data <- mutate(data, msexism = (msexism - 1) / 6)

#______________________________________________________________________________#
# (18): Variable for modern sexism according to Swim et al. (1995)

# ... we first calculate row mean of the variables imsex_1 through imsex_8 ... 
data <- mutate(data, swim_msex = rowMeans(select(data, starts_with("imsex_")), na.rm = F))
# ... and then rescale values of the created variable "swim_msex" ...
data <- mutate(data, swim_msex = (swim_msex - 1) / 6)

#______________________________________________________________________________#
# (19): Variable for respondent's engagement in Women's Day protests 

# ... we first dichotomize th variables "femstrike", "femdemonstrate", "feminfo", "femtalk", and generate corresponding new binary variables for each ... 

data$p8m_strike <- ifelse(data$femstrike == 1, 1, 0) # first variable created -> "p8m_strike"
data$p8m_demonst <- ifelse(data$femdemonstrate == 1, 1, 0) # second variable created -> "p8m_demonst"
data$p8m_mobiliz <- ifelse(data$feminfo == 1, 1, 0) # third variable created -> "p8m_mobiliz"
data$p8m_talked <- ifelse(data$femtalk == 1, 1, 0) # fourth variable created -> "p8m_talked"

# ... and finally estimate the row mean for each observation out of the four generated variables above ... 
data$ip8m <- rowMeans(data[, c("p8m_strike", "p8m_demonst", "p8m_mobiliz", "p8m_talked")])

#______________________________________________________________________________#
# (20): Respondent's intended vote for the Vox-party (MAIN DEPENDENT VARIABLE)

data$vim_vox <- ifelse(data$voteintentionspain == 23, 1, 0) # the values for the created binary variable ("vim_vox") are defined as a function of the values for the already existing variable "voteintentionspain" 

#______________________________________________________________________________#
# (20): Respondent's intended vote for the PP-party (PLACEBO DEPENDENT VARIABLE)

data$vim_pp <- ifelse(data$voteintentionspain == 2, 1, 0) # the values for the created binary variable ("vim_pp") are defined as a function of the values for the already existing variable "voteintentionspain" 

#______________________________________________________________________________#


data$cut_violence <- (data$violence - 1) / 4

```

